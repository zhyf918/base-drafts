<!DOCTYPE html>
<html lang="en" class="Internet-Draft">
<head>
<meta charset="utf-8">
<meta content="Common,Latin" name="scripts">
<meta content="initial-scale=1.0" name="viewport">
<title>QUIC Loss Detection and Congestion Control</title>
<meta content="Jana Iyengar" name="author">
<meta content="Ian Swett" name="author">
<meta content="
       This document describes loss detection and congestion control mechanisms for
QUIC. 
    " name="description">
<meta content="xml2rfc 3.3.0" name="generator">
<meta content="draft-ietf-quic-recovery" name="ietf.draft">
<!-- Generator version information:
  xml2rfc 3.3.0
    Python 3.8.5
    appdirs 1.4.4
    ConfigArgParse 1.2.3
    google-i18n-address 2.4.0
    html5lib 1.1
    intervaltree 3.0.2
    Jinja2 2.11.2
    kitchen 1.2.6
    lxml 4.5.0
    pycountry 19.8.18
    pyflakes 2.1.1
    PyYAML 5.3.1
    requests 2.22.0
    setuptools 45.2.0
    six 1.14.0
-->
<link href="draft-ietf-quic-recovery.xml" rel="alternate" type="application/rfc+xml">
<link href="#copyright" rel="license">
<style type="text/css">@import url('https://martinthomson.github.io/i-d-template/fonts.css');

html {
  --background-color: #fff;
  --text-color: #222;
  --title-color: #191919;
  --link-color: #2a6496;
  --highlight-color: #f9f9f9;
  --line-color: #eee;
  --small-font-size: 14.5px;
}
body {
  max-width: 600px;
  margin: 75px auto;
  padding: 0 5px;
  color: var(--text-color);
  background-color: var(--background-color);
  font: 16px/22px "Lora", serif;
  scroll-behavior: smooth;
}

.ears {
  display: none;
}

/* headings */
#title, h1, h2, h3, h4, h5, h6 {
  font-family: "Cabin Condensed", sans-serif;
  font-weight: 600;
  margin: 0.8em 0 0.3em;
  font-size-adjust: 0.5;
  color: var(--title-color);
}
#title {
  padding: 1em 0 0.2em;
  font-size: 32px;
  line-height: 40px;
  clear: both;
}
h1, h2, h3 {
  font-size: 22px;
  line-height: 26px;
}
h4, h5, h6 {
  font-size: 18px;
  line-height: 22px;
}

/* general structure */
.author {
  padding-bottom: 0.3em;
}
#abstract+p, #abstract+p code, #abstract+p samp, #abstract+p tt {
  font-size: 18px;
  line-height: 24px;
}
p {
  padding: 0;
  margin: 0.5em 0;
  text-align: left;
}
div {
  margin: 0;
}
.alignRight.art-text {
  background-color: var(--highlight-color);
  border: 1px solid var(--line-color);
  border-radius: 3px;
  padding: 0.5em 1em 0;
  margin-bottom: 0.5em;
}
.alignRight.art-text pre {
  padding: 0;
  width: auto;
}
.alignRight {
  margin: 1em 0;
}
.alignRight > *:first-child {
  border: none;
  margin: 0;
  float: right;
  clear: both;
}
.alignRight > *:nth-child(2) {
  clear: both;
  display: block;
  border: none;
}
svg {
  display: block;
}
.alignCenter.art-text {
  background-color: var(--highlight-color);
  border: 1px solid var(--line-color);
  border-radius: 3px;
  padding: 0.5em 1em 0;
  margin-bottom: 0.5em;
}
.alignCenter.art-text pre {
  padding: 0;
  width: auto;
}
.alignCenter {
  margin: 1em 0;
}
.alignCenter > *:first-child {
  border: none;
  /* this isn't optimal, but it's an existence proof.  PrinceXML doesn't
     support flexbox yet.
  */
  display: table;
  margin: 0 auto;
}

/* lists */
ol, ul {
  padding: 0;
  margin: 0 0 0.5em 2em;
}
ol ol, ul ul, ol ul, ul ol {
  margin-left: 1em;
}
li {
  margin: 0 0 0.25em 0;
}
.ulCompact li {
  margin: 0;
}
ul.empty, .ulEmpty {
  list-style-type: none;
}
ul.empty li, .ulEmpty li {
  margin-top: 0.5em;
}
ul.compact, .ulCompact,
ol.compact, .olCompact {
  line-height: 100%;
  margin: 0 0 0 2em;
}

/* definition lists */
dl {
}
dl > dt {
  float: left;
  margin-right: 1em;
}
dl > dd {
  margin-bottom: .8em;
  min-height: 1.3em;
}
dl.compact > dd, .dlCompact > dd {
  margin-bottom: 0em;
}
dl > dd > dl {
  margin-top: 0.5em;
  margin-bottom: 0em;
}
dd.break {
  display: none;
}

/* links */
a, a[href].selfRef:hover {
  text-decoration: none;
}
a[href].selfRef {
  color: var(--text-color);
}
a[href] {
  color: var(--link-color);
}
a[href]:hover {
  text-decoration: underline;
}
a[href].selfRef:hover {
  background-color: var(--highlight-color);
}
a.xref {
  white-space: nowrap;
}

/* Figures */
tt, code, pre {
  background-color: var(--highlight-color);
  font: 14px/22px 'Oxygen Mono', monospace;
}
pre {
  border: 1px solid var(--line-color);
  font-size: 13.5px;
  line-height: 16px;
  letter-spacing: -0.2px;
  margin: 5px;
  padding: 5px;
}
img {
  max-width: 100%;
}
figure {
  margin: 0.5em 0;
}
figure blockquote {
  margin: 0.8em 0.4em 0.4em;
}
figcaption, caption {
  font-style: italic;
  margin: 0.5em 1.5em;
  text-align: left;
}
@media screen {
  pre {
    display: inline-block;
    overflow-x: auto;
    max-width: 100%;
    width: calc(100% - 22px - 1em);
  }
  figure pre {
    display: block;
    width: calc(100% - 25px);
  }
  pre + .pilcrow {
    display: inline-block;
    vertical-align: text-bottom;
    padding-bottom: 8px;
  }
  table {
    display: inline-block;
    overflow-x: auto;
  }
}

/* aside, blockquote */
aside, blockquote {
  margin-left: 0;
  padding: 0 2em;
  font-style: italic;
}
blockquote {
  background-color: var(--highlight-color);
  border: 1px solid var(--line-color);
  border-radius: 3px;
  margin: 1em 0;
}
cite {
  display: block;
  text-align: right;
  font-style: italic;
}

/* tables */
table {
  max-width: 100%;
  margin: 0 0 1em;
  border-collapse: collapse;
}
table.right {
  margin-left: auto;
}
table.center {
  margin-left: auto;
  margin-right: auto;
}
table.left {
  margin-right: auto;
}
thead, tbody {
  border: 1px solid var(--line-color);
}
th, td {
  text-align: left;
  vertical-align: top;
  padding: 5px 10px;
}
th {
  background-color: var(--line-color);
}
tr:nth-child(2n) > td {
  background-color: var(--background-color);
}
tr:nth-child(2n+1) > td {
  background-color: var(--highlight-color);
}
thead+tbody > tr:nth-child(2n) > td {
  background-color: var(--highlight-color);
}
thead+tbody > tr:nth-child(2n+1) > td {
  background-color: var(--background-color);
}
table caption {
  margin: 0;
  padding: 3px 0 3px 1em;
}
table p {
  margin: 0;
}

/* pilcrow */
a.pilcrow {
  margin-left: 3px;
  visibility: hidden;
  user-select: none;
}
a.pilcrow[href] { color: #ddd; }
a.pilcrow[href]:hover { text-decoration: none; }
@media screen {
  :hover > a.pilcrow {
    visibility: visible;
  }
  a.pilcrow:hover {
    background-color: transparent;
  }
}

/* misc */
hr {
  border: 0;
  border-top: 1px solid var(--line-color);
}
.bcp14 {
  font-variant: small-caps;
}

.role {
  font-variant: all-small-caps;
}

/* info block */
#identifiers {
  margin: 0;
  font-size: var(--small-font-size);
  line-height: 18px;
  --identifier-width: 8em;
}
#identifiers dt {
  width: var(--identifier-width);
  margin: 0;
  clear: left;
  float: left;
  text-align: right;
}
#identifiers dd {
  margin: 0 0 0 calc(1em + var(--identifier-width));
  min-width: 5em;
}
#identifiers .authors .author {
  display: inline-block;
  margin-right: 1.5em;
}
#identifiers .authors .org {
  font-style: italic;
}

/* The prepared/rendered info at the very bottom of the page */
.docInfo {
  color: #999;
  font-size: 0.9em;
  font-style: italic;
  margin-top: 2em;
}
.docInfo .prepared {
  float: left;
}
.docInfo .prepared {
  float: right;
}

/* table of contents */
#toc {
  padding: 0.75em 0 2em 0;
  margin-bottom: 1em;
}
#toc nav ul {
  margin: 0 0.5em 0 0;
  padding: 0;
  list-style: none;
}
#toc nav li {
  line-height: 1.3em;
  margin: 0.75em 0;
  padding-left: 1.2em;
  text-indent: -1.2em;
}
#toc a.xref {
  white-space: normal;
}
/* references */
.references dt {
  text-align: right;
  font-weight: bold;
  min-width: 7em;
}
.references dd {
  margin-left: 8em;
  overflow: auto;
}

.refInstance {
  margin-bottom: 1.25em;
}

.references .ascii {
  margin-bottom: 0.25em;
}

/* index */
.index ul {
  margin: 0 0 0 1em;
  padding: 0;
  list-style: none;
}
.index ul ul {
  margin: 0;
}
.index li {
  margin: 0;
  text-indent: -2em;
  padding-left: 2em;
  padding-bottom: 5px;
}
.indexIndex {
  margin: 0.5em 0 1em;
}
.index a {
  font-weight: 700;
}
/* make the index two-column on all but the smallest screens */
@media (min-width: 500px) {
  .index ul {
    column-count: 2;
    column-gap: 20px;
  }
  .index ul ul {
    column-count: 1;
    column-gap: 0;
  }
}

/* authors */
address.vcard {
  font-style: normal;
  margin: 1em 0;
}
address.vcard .nameRole {
  font-weight: 700;
  margin-left: 0;
}
address.vcard .label {
  margin: 0.5em 0;
}
address.vcard .type {
  display: none;
}
.alternative-contact {
  margin: 1.5em 0 1em;
}
hr.addr {
  border-top: 1px dashed;
  margin: 0;
  color: #ddd;
  max-width: calc(100% - 16px);
}
@media (min-width: 500px) {
  #authors-addresses > section {
    column-count: 2;
    column-gap: 20px;
  }
  #authors-addresses > section > h2 {
    column-span: all;
  }
  /* hack for break-inside: avoid-column */
  #authors-addresses address {
    display: inline-block;
    break-inside: avoid-column;
  }
}

.rfcEditorRemove p:first-of-type {
  font-style: italic;
}
.cref {
  background-color: rgba(249, 232, 105, 0.3);
  padding: 2px 4px;
}
.crefSource {
  font-style: italic;
}
/* alternative layout for smaller screens */
@media screen and (max-width: 929px) {
  #toc {
    position: fixed;
    z-index: 2;
    top: 0;
    right: 0;
    padding: 0;
    margin: 0;
    border-bottom: 1px solid #ccc;
    opacity: 0.6;
  }
  #toc.active {
      opacity: 1;
  }
  #toc h2 {
    margin: 0;
    padding: 2px 0 2px 6px;
    padding-right: 1em;
    font-size: 18px;
    line-height: 24px;
    min-width: 190px;
    text-align: right;
    background-color: #444;
    color: white;
    cursor: pointer;
  }
  #toc h2::before { /* css hamburger */
    float: right;
    position: relative;
    width: 1em;
    height: 1px;
    left: -164px;
    margin: 8px 0 0 0;
    background: white none repeat scroll 0 0;
    box-shadow: 0 4px 0 0 white, 0 8px 0 0 white;
    content: "";
  }
  #toc nav {
    display: none;
    background-color: var(--background-color);
    padding: 0.5em 1em 1em;
    overflow: auto;
    overscroll-behavior: contain;
    height: calc(100vh - 48px);
    border-left: 1px solid #ddd;
  }
  #toc.active nav {
    display: block;
  }
  /* Make the collapsed ToC header render white on gray also when it's a link */
  #toc h2 a,
  #toc h2 a:link,
  #toc h2 a:focus,
  #toc h2 a:hover,
  #toc a.toplink,
  #toc a.toplink:hover {
    color: white;
    background-color: #444;
    text-decoration: none;
  }
  #toc a.toplink {
    margin-top: 2px;
  }
}

/* alternative layout for wide screens */
@media screen and (min-width: 930px) {
  body {
    padding-right: 360px;
    padding-right: calc(min(180px + 20%, 500px));
  }
  #toc {
    position: fixed;
    bottom: 0;
    right: 0;
    right: calc(50vw - 480px);
    width: 312px;
    margin: 0;
    padding: 0;
    z-index: 1;
  }
  #toc h2 {
    margin: 0;
    padding: 0.25em 1em 1em 0;
  }
  #toc nav {
    display: block;
    height: calc(90vh - 84px);
    bottom: 0;
    padding: 0.5em 0 2em;
    overflow: auto;
    overscroll-behavior: contain;
    scrollbar-width: thin;
  }
  #toc nav > ul  {
    margin-bottom: 2em;
  }
  #toc ul {
    margin: 0 0 0 4px;
    font-size: var(--small-font-size);
  }
  #toc ul p, #toc ul li {
    margin: 2px 0;
    line-height: 22px;
  }
  img { /* future proofing */
    max-width: 100%;
    height: auto;
  }
}

/* pagination */
@media print {
  body {
    width: 100%;
  }
  p {
    orphans: 3;
    widows: 3;
  }
  #n-copyright-notice {
    border-bottom: none;
  }
  #toc, #n-introduction {
    page-break-before: always;
  }
  #toc {
    border-top: none;
    padding-top: 0;
  }
  figure, pre {
    page-break-inside: avoid;
  }
  figure {
    overflow: scroll;
  }
  h1, h2, h3, h4, h5, h6 {
    page-break-after: avoid;
  }
  h2+*, h3+*, h4+*, h5+*, h6+* {
    page-break-before: avoid;
  }
  pre {
    white-space: pre-wrap;
    word-wrap: break-word;
    font-size: 10pt;
  }
  table {
    border: 1px solid #ddd;
  }
  td {
    border-top: 1px solid #ddd;
  }
}

@page :first {
  padding-top: 0;
  @top-left {
    content: normal;
    border: none;
  }
  @top-center {
    content: normal;
    border: none;
  }
  @top-right {
    content: normal;
    border: none;
  }
}

@page {
  size: A4;
  margin-bottom: 45mm;
  padding-top: 20px;
}

/* Changes introduced to fix issues found during implementation */

/* Separate body from document info even without intervening H1 */
section {
  clear: both;
}

/* Top align author divs, to avoid names without organization dropping level with org names */
.author {
  vertical-align: top;
}

/* Style section numbers with more space between number and title */
.section-number {
  padding-right: 0.5em;
}

/* Add styling for a link in the ToC that points to the top of the document */
a.toplink {
  float: right;
  margin: 8px 0.5em 0;
}

/* Fix the dl styling to match the RFC 7992 attributes */
dl > dt,
dl.dlParallel > dt {
  float: left;
  margin-right: 1em;
}
dl.dlNewline > dt {
  float: none;
}

/* Provide styling for table cell text alignment */
table .text-left, table .text-left {
  text-align: left;
}
table .text-center, table .text-center {
  text-align: center;
}
table .text-right, table .text-right {
  text-align: right;
}

/* Make the alternative author contact information look less like just another
   author, and group it closer with the primary author contact information */
.alternative-contact {
  margin: 0.5em 0 0.25em 0;
}
address .non-ascii {
  margin: 0 0 0 2em;
}

/* With it being possible to set tables with alignment
  left, center, and right, { width: 100%; } does not make sense */
table {
  width: auto;
}

/* Avoid reference text that sits in a block with very wide left margin,
   because of a long floating dt label.*/
.references dd {
  overflow: visible;
}

/* Control caption placement */
caption {
  caption-side: bottom;
}

/* Limit the width of the author address vcard, so names in right-to-left
   script don't end up on the other side of the page. */

address.vcard {
  max-width: 20em;
  margin-right: auto;
}

/* For address alignment dependent on LTR or RTL scripts */
address div.left {
  text-align: left;
}
address div.right {
  text-align: right;
}

/* Give the table caption label the same styling as the figcaption */

@media print {
  .toplink {
    display: none;
  }

  /* avoid overwriting the top border line with the ToC header */
  #toc {
    padding-top: 1px;
  }

  /* Avoid page breaks inside dl and author address entries */
  dd {
    page-break-before: avoid;
  }
  .vcard {
    page-break-inside: avoid;
  }

}
/* Tweak the bcp14 keyword presentation */
.bcp14 {
  font-variant: small-caps;
  font-weight: bold;
  font-size: 0.9em;
}
</style>

</head>
<body>
<table class="ears">
<thead><tr>
<td class="left">Internet-Draft</td>
<td class="center">QUIC Loss Detection</td>
<td class="right">November 2020</td>
</tr></thead>
<tfoot><tr>
<td class="left">Iyengar &amp; Swett</td>
<td class="center">Expires 22 May 2021</td>
<td class="right">[Page]</td>
</tr></tfoot>
</table>
<div id="external-metadata" class="document-information"></div>
<div id="internal-metadata" class="document-information">
<dl id="identifiers">
<dt class="label-workgroup">Workgroup:</dt>
<dd class="workgroup">QUIC</dd>
<dt class="label-internet-draft">Internet-Draft:</dt>
<dd class="internet-draft">draft-ietf-quic-recovery</dd>
<dt class="label-published">Published:</dt>
<dd class="published">
<time datetime="2020-11-18" class="published">18 November 2020</time>
    </dd>
<dt class="label-intended-status">Intended Status:</dt>
<dd class="intended-status">Standards Track</dd>
<dt class="label-expires">Expires:</dt>
<dd class="expires"><time datetime="2021-05-22">22 May 2021</time></dd>
<dt class="label-authors">Authors:</dt>
<dd class="authors">
<div class="author">
      <div class="author-name">J. Iyengar, <span class="editor">Ed.</span>
</div>
<div class="org">Fastly</div>
</div>
<div class="author">
      <div class="author-name">I. Swett, <span class="editor">Ed.</span>
</div>
<div class="org">Google</div>
</div>
</dd>
</dl>
</div>
<h1 id="title">QUIC Loss Detection and Congestion Control</h1>
<section id="section-abstract">
      <h2 id="abstract"><a href="#abstract" class="selfRef">Abstract</a></h2>
<p id="section-abstract-1">This document describes loss detection and congestion control mechanisms for
QUIC.<a href="#section-abstract-1" class="pilcrow">¶</a></p>
</section>
<section class="note" id="section-note.1">
      <h2 id="name-note-to-readers">
<a href="#name-note-to-readers" class="section-name selfRef">Note to Readers</a>
      </h2>
<p id="section-note.1-1">Discussion of this draft takes place on the QUIC working group mailing list
(<a href="mailto:quic@ietf.org">quic@ietf.org</a>), which is archived at
<span><a href="https://mailarchive.ietf.org/arch/search/?email_list=quic">https://mailarchive.ietf.org/arch/search/?email_list=quic</a></span>.<a href="#section-note.1-1" class="pilcrow">¶</a></p>
<p id="section-note.1-2">Working Group information can be found at <span><a href="https://github.com/quicwg">https://github.com/quicwg</a></span>; source
code and issues list for this draft can be found at
<span><a href="https://github.com/quicwg/base-drafts/labels/-recovery">https://github.com/quicwg/base-drafts/labels/-recovery</a></span>.<a href="#section-note.1-2" class="pilcrow">¶</a></p>
</section>
<div id="status-of-memo">
<section id="section-boilerplate.1">
        <h2 id="name-status-of-this-memo">
<a href="#name-status-of-this-memo" class="section-name selfRef">Status of This Memo</a>
        </h2>
<p id="section-boilerplate.1-1">
        This Internet-Draft is submitted in full conformance with the
        provisions of BCP 78 and BCP 79.<a href="#section-boilerplate.1-1" class="pilcrow">¶</a></p>
<p id="section-boilerplate.1-2">
        Internet-Drafts are working documents of the Internet Engineering Task
        Force (IETF). Note that other groups may also distribute working
        documents as Internet-Drafts. The list of current Internet-Drafts is
        at <span><a href="https://datatracker.ietf.org/drafts/current/">https://datatracker.ietf.org/drafts/current/</a></span>.<a href="#section-boilerplate.1-2" class="pilcrow">¶</a></p>
<p id="section-boilerplate.1-3">
        Internet-Drafts are draft documents valid for a maximum of six months
        and may be updated, replaced, or obsoleted by other documents at any
        time. It is inappropriate to use Internet-Drafts as reference
        material or to cite them other than as "work in progress."<a href="#section-boilerplate.1-3" class="pilcrow">¶</a></p>
<p id="section-boilerplate.1-4">
        This Internet-Draft will expire on 22 May 2021.<a href="#section-boilerplate.1-4" class="pilcrow">¶</a></p>
</section>
</div>
<div id="copyright">
<section id="section-boilerplate.2">
        <h2 id="name-copyright-notice">
<a href="#name-copyright-notice" class="section-name selfRef">Copyright Notice</a>
        </h2>
<p id="section-boilerplate.2-1">
            Copyright (c) 2020 IETF Trust and the persons identified as the
            document authors. All rights reserved.<a href="#section-boilerplate.2-1" class="pilcrow">¶</a></p>
<p id="section-boilerplate.2-2">
            This document is subject to BCP 78 and the IETF Trust's Legal
            Provisions Relating to IETF Documents
            (<span><a href="https://trustee.ietf.org/license-info">https://trustee.ietf.org/license-info</a></span>) in effect on the date of
            publication of this document. Please review these documents
            carefully, as they describe your rights and restrictions with
            respect to this document. Code Components extracted from this
            document must include Simplified BSD License text as described in
            Section 4.e of the Trust Legal Provisions and are provided without
            warranty as described in the Simplified BSD License.<a href="#section-boilerplate.2-2" class="pilcrow">¶</a></p>
</section>
</div>
<div id="toc">
<section id="section-toc.1">
        <a href="#" onclick="scroll(0,0)" class="toplink">▲</a><h2 id="name-table-of-contents">
<a href="#name-table-of-contents" class="section-name selfRef">Table of Contents</a>
        </h2>
<nav class="toc"><ul class="compact toc ulEmpty">
<li class="compact toc ulEmpty" id="section-toc.1-1.1">
            <p id="section-toc.1-1.1.1" class="keepWithNext"><a href="#section-1" class="xref">1</a>.  <a href="#name-introduction" class="xref">Introduction</a><a href="#section-toc.1-1.1.1" class="pilcrow">¶</a></p>
</li>
          <li class="compact toc ulEmpty" id="section-toc.1-1.2">
            <p id="section-toc.1-1.2.1" class="keepWithNext"><a href="#section-2" class="xref">2</a>.  <a href="#name-conventions-and-definitions" class="xref">Conventions and Definitions</a><a href="#section-toc.1-1.2.1" class="pilcrow">¶</a></p>
</li>
          <li class="compact toc ulEmpty" id="section-toc.1-1.3">
            <p id="section-toc.1-1.3.1" class="keepWithNext"><a href="#section-3" class="xref">3</a>.  <a href="#name-design-of-the-quic-transmis" class="xref">Design of the QUIC Transmission Machinery</a><a href="#section-toc.1-1.3.1" class="pilcrow">¶</a></p>
</li>
          <li class="compact toc ulEmpty" id="section-toc.1-1.4">
            <p id="section-toc.1-1.4.1"><a href="#section-4" class="xref">4</a>.  <a href="#name-relevant-differences-betwee" class="xref">Relevant Differences Between QUIC and TCP</a><a href="#section-toc.1-1.4.1" class="pilcrow">¶</a></p>
<ul class="compact ulEmpty toc">
<li class="compact ulEmpty toc" id="section-toc.1-1.4.2.1">
                <p id="section-toc.1-1.4.2.1.1"><a href="#section-4.1" class="xref">4.1</a>.  <a href="#name-separate-packet-number-spac" class="xref">Separate Packet Number Spaces</a><a href="#section-toc.1-1.4.2.1.1" class="pilcrow">¶</a></p>
</li>
              <li class="compact ulEmpty toc" id="section-toc.1-1.4.2.2">
                <p id="section-toc.1-1.4.2.2.1"><a href="#section-4.2" class="xref">4.2</a>.  <a href="#name-monotonically-increasing-pa" class="xref">Monotonically Increasing Packet Numbers</a><a href="#section-toc.1-1.4.2.2.1" class="pilcrow">¶</a></p>
</li>
              <li class="compact ulEmpty toc" id="section-toc.1-1.4.2.3">
                <p id="section-toc.1-1.4.2.3.1"><a href="#section-4.3" class="xref">4.3</a>.  <a href="#name-clearer-loss-epoch" class="xref">Clearer Loss Epoch</a><a href="#section-toc.1-1.4.2.3.1" class="pilcrow">¶</a></p>
</li>
              <li class="compact ulEmpty toc" id="section-toc.1-1.4.2.4">
                <p id="section-toc.1-1.4.2.4.1"><a href="#section-4.4" class="xref">4.4</a>.  <a href="#name-no-reneging" class="xref">No Reneging</a><a href="#section-toc.1-1.4.2.4.1" class="pilcrow">¶</a></p>
</li>
              <li class="compact ulEmpty toc" id="section-toc.1-1.4.2.5">
                <p id="section-toc.1-1.4.2.5.1"><a href="#section-4.5" class="xref">4.5</a>.  <a href="#name-more-ack-ranges" class="xref">More ACK Ranges</a><a href="#section-toc.1-1.4.2.5.1" class="pilcrow">¶</a></p>
</li>
              <li class="compact ulEmpty toc" id="section-toc.1-1.4.2.6">
                <p id="section-toc.1-1.4.2.6.1"><a href="#section-4.6" class="xref">4.6</a>.  <a href="#name-explicit-correction-for-del" class="xref">Explicit Correction For Delayed Acknowledgements</a><a href="#section-toc.1-1.4.2.6.1" class="pilcrow">¶</a></p>
</li>
              <li class="compact ulEmpty toc" id="section-toc.1-1.4.2.7">
                <p id="section-toc.1-1.4.2.7.1"><a href="#section-4.7" class="xref">4.7</a>.  <a href="#name-probe-timeout-replaces-rto-" class="xref">Probe Timeout Replaces RTO and TLP</a><a href="#section-toc.1-1.4.2.7.1" class="pilcrow">¶</a></p>
</li>
              <li class="compact ulEmpty toc" id="section-toc.1-1.4.2.8">
                <p id="section-toc.1-1.4.2.8.1"><a href="#section-4.8" class="xref">4.8</a>.  <a href="#name-the-minimum-congestion-wind" class="xref">The Minimum Congestion Window is Two Packets</a><a href="#section-toc.1-1.4.2.8.1" class="pilcrow">¶</a></p>
</li>
            </ul>
</li>
          <li class="compact toc ulEmpty" id="section-toc.1-1.5">
            <p id="section-toc.1-1.5.1"><a href="#section-5" class="xref">5</a>.  <a href="#name-estimating-the-round-trip-t" class="xref">Estimating the Round-Trip Time</a><a href="#section-toc.1-1.5.1" class="pilcrow">¶</a></p>
<ul class="compact ulEmpty toc">
<li class="compact ulEmpty toc" id="section-toc.1-1.5.2.1">
                <p id="section-toc.1-1.5.2.1.1"><a href="#section-5.1" class="xref">5.1</a>.  <a href="#name-generating-rtt-samples" class="xref">Generating RTT samples</a><a href="#section-toc.1-1.5.2.1.1" class="pilcrow">¶</a></p>
</li>
              <li class="compact ulEmpty toc" id="section-toc.1-1.5.2.2">
                <p id="section-toc.1-1.5.2.2.1"><a href="#section-5.2" class="xref">5.2</a>.  <a href="#name-estimating-min_rtt" class="xref">Estimating min_rtt</a><a href="#section-toc.1-1.5.2.2.1" class="pilcrow">¶</a></p>
</li>
              <li class="compact ulEmpty toc" id="section-toc.1-1.5.2.3">
                <p id="section-toc.1-1.5.2.3.1"><a href="#section-5.3" class="xref">5.3</a>.  <a href="#name-estimating-smoothed_rtt-and" class="xref">Estimating smoothed_rtt and rttvar</a><a href="#section-toc.1-1.5.2.3.1" class="pilcrow">¶</a></p>
</li>
            </ul>
</li>
          <li class="compact toc ulEmpty" id="section-toc.1-1.6">
            <p id="section-toc.1-1.6.1"><a href="#section-6" class="xref">6</a>.  <a href="#name-loss-detection" class="xref">Loss Detection</a><a href="#section-toc.1-1.6.1" class="pilcrow">¶</a></p>
<ul class="compact ulEmpty toc">
<li class="compact ulEmpty toc" id="section-toc.1-1.6.2.1">
                <p id="section-toc.1-1.6.2.1.1"><a href="#section-6.1" class="xref">6.1</a>.  <a href="#name-acknowledgement-based-detec" class="xref">Acknowledgement-Based Detection</a><a href="#section-toc.1-1.6.2.1.1" class="pilcrow">¶</a></p>
<ul class="compact ulEmpty toc">
<li class="compact ulEmpty toc" id="section-toc.1-1.6.2.1.2.1">
                    <p id="section-toc.1-1.6.2.1.2.1.1"><a href="#section-6.1.1" class="xref">6.1.1</a>.  <a href="#name-packet-threshold" class="xref">Packet Threshold</a><a href="#section-toc.1-1.6.2.1.2.1.1" class="pilcrow">¶</a></p>
</li>
                  <li class="compact ulEmpty toc" id="section-toc.1-1.6.2.1.2.2">
                    <p id="section-toc.1-1.6.2.1.2.2.1"><a href="#section-6.1.2" class="xref">6.1.2</a>.  <a href="#name-time-threshold" class="xref">Time Threshold</a><a href="#section-toc.1-1.6.2.1.2.2.1" class="pilcrow">¶</a></p>
</li>
                </ul>
</li>
              <li class="compact ulEmpty toc" id="section-toc.1-1.6.2.2">
                <p id="section-toc.1-1.6.2.2.1"><a href="#section-6.2" class="xref">6.2</a>.  <a href="#name-probe-timeout" class="xref">Probe Timeout</a><a href="#section-toc.1-1.6.2.2.1" class="pilcrow">¶</a></p>
<ul class="compact ulEmpty toc">
<li class="compact ulEmpty toc" id="section-toc.1-1.6.2.2.2.1">
                    <p id="section-toc.1-1.6.2.2.2.1.1"><a href="#section-6.2.1" class="xref">6.2.1</a>.  <a href="#name-computing-pto" class="xref">Computing PTO</a><a href="#section-toc.1-1.6.2.2.2.1.1" class="pilcrow">¶</a></p>
</li>
                  <li class="compact ulEmpty toc" id="section-toc.1-1.6.2.2.2.2">
                    <p id="section-toc.1-1.6.2.2.2.2.1"><a href="#section-6.2.2" class="xref">6.2.2</a>.  <a href="#name-handshakes-and-new-paths" class="xref">Handshakes and New Paths</a><a href="#section-toc.1-1.6.2.2.2.2.1" class="pilcrow">¶</a></p>
</li>
                  <li class="compact ulEmpty toc" id="section-toc.1-1.6.2.2.2.3">
                    <p id="section-toc.1-1.6.2.2.2.3.1"><a href="#section-6.2.3" class="xref">6.2.3</a>.  <a href="#name-speeding-up-handshake-compl" class="xref">Speeding Up Handshake Completion</a><a href="#section-toc.1-1.6.2.2.2.3.1" class="pilcrow">¶</a></p>
</li>
                  <li class="compact ulEmpty toc" id="section-toc.1-1.6.2.2.2.4">
                    <p id="section-toc.1-1.6.2.2.2.4.1"><a href="#section-6.2.4" class="xref">6.2.4</a>.  <a href="#name-sending-probe-packets" class="xref">Sending Probe Packets</a><a href="#section-toc.1-1.6.2.2.2.4.1" class="pilcrow">¶</a></p>
</li>
                </ul>
</li>
              <li class="compact ulEmpty toc" id="section-toc.1-1.6.2.3">
                <p id="section-toc.1-1.6.2.3.1"><a href="#section-6.3" class="xref">6.3</a>.  <a href="#name-handling-retry-packets" class="xref">Handling Retry Packets</a><a href="#section-toc.1-1.6.2.3.1" class="pilcrow">¶</a></p>
</li>
              <li class="compact ulEmpty toc" id="section-toc.1-1.6.2.4">
                <p id="section-toc.1-1.6.2.4.1"><a href="#section-6.4" class="xref">6.4</a>.  <a href="#name-discarding-keys-and-packet-" class="xref">Discarding Keys and Packet State</a><a href="#section-toc.1-1.6.2.4.1" class="pilcrow">¶</a></p>
</li>
            </ul>
</li>
          <li class="compact toc ulEmpty" id="section-toc.1-1.7">
            <p id="section-toc.1-1.7.1"><a href="#section-7" class="xref">7</a>.  <a href="#name-congestion-control" class="xref">Congestion Control</a><a href="#section-toc.1-1.7.1" class="pilcrow">¶</a></p>
<ul class="compact ulEmpty toc">
<li class="compact ulEmpty toc" id="section-toc.1-1.7.2.1">
                <p id="section-toc.1-1.7.2.1.1"><a href="#section-7.1" class="xref">7.1</a>.  <a href="#name-explicit-congestion-notific" class="xref">Explicit Congestion Notification</a><a href="#section-toc.1-1.7.2.1.1" class="pilcrow">¶</a></p>
</li>
              <li class="compact ulEmpty toc" id="section-toc.1-1.7.2.2">
                <p id="section-toc.1-1.7.2.2.1"><a href="#section-7.2" class="xref">7.2</a>.  <a href="#name-initial-and-minimum-congest" class="xref">Initial and Minimum Congestion Window</a><a href="#section-toc.1-1.7.2.2.1" class="pilcrow">¶</a></p>
</li>
              <li class="compact ulEmpty toc" id="section-toc.1-1.7.2.3">
                <p id="section-toc.1-1.7.2.3.1"><a href="#section-7.3" class="xref">7.3</a>.  <a href="#name-congestion-control-states" class="xref">Congestion Control States</a><a href="#section-toc.1-1.7.2.3.1" class="pilcrow">¶</a></p>
<ul class="compact ulEmpty toc">
<li class="compact ulEmpty toc" id="section-toc.1-1.7.2.3.2.1">
                    <p id="section-toc.1-1.7.2.3.2.1.1"><a href="#section-7.3.1" class="xref">7.3.1</a>.  <a href="#name-slow-start" class="xref">Slow Start</a><a href="#section-toc.1-1.7.2.3.2.1.1" class="pilcrow">¶</a></p>
</li>
                  <li class="compact ulEmpty toc" id="section-toc.1-1.7.2.3.2.2">
                    <p id="section-toc.1-1.7.2.3.2.2.1"><a href="#section-7.3.2" class="xref">7.3.2</a>.  <a href="#name-recovery" class="xref">Recovery</a><a href="#section-toc.1-1.7.2.3.2.2.1" class="pilcrow">¶</a></p>
</li>
                  <li class="compact ulEmpty toc" id="section-toc.1-1.7.2.3.2.3">
                    <p id="section-toc.1-1.7.2.3.2.3.1"><a href="#section-7.3.3" class="xref">7.3.3</a>.  <a href="#name-congestion-avoidance" class="xref">Congestion Avoidance</a><a href="#section-toc.1-1.7.2.3.2.3.1" class="pilcrow">¶</a></p>
</li>
                </ul>
</li>
              <li class="compact ulEmpty toc" id="section-toc.1-1.7.2.4">
                <p id="section-toc.1-1.7.2.4.1"><a href="#section-7.4" class="xref">7.4</a>.  <a href="#name-ignoring-loss-of-undecrypta" class="xref">Ignoring Loss of Undecryptable Packets</a><a href="#section-toc.1-1.7.2.4.1" class="pilcrow">¶</a></p>
</li>
              <li class="compact ulEmpty toc" id="section-toc.1-1.7.2.5">
                <p id="section-toc.1-1.7.2.5.1"><a href="#section-7.5" class="xref">7.5</a>.  <a href="#name-probe-timeout-2" class="xref">Probe Timeout</a><a href="#section-toc.1-1.7.2.5.1" class="pilcrow">¶</a></p>
</li>
              <li class="compact ulEmpty toc" id="section-toc.1-1.7.2.6">
                <p id="section-toc.1-1.7.2.6.1"><a href="#section-7.6" class="xref">7.6</a>.  <a href="#name-persistent-congestion" class="xref">Persistent Congestion</a><a href="#section-toc.1-1.7.2.6.1" class="pilcrow">¶</a></p>
<ul class="compact ulEmpty toc">
<li class="compact ulEmpty toc" id="section-toc.1-1.7.2.6.2.1">
                    <p id="section-toc.1-1.7.2.6.2.1.1"><a href="#section-7.6.1" class="xref">7.6.1</a>.  <a href="#name-duration" class="xref">Duration</a><a href="#section-toc.1-1.7.2.6.2.1.1" class="pilcrow">¶</a></p>
</li>
                  <li class="compact ulEmpty toc" id="section-toc.1-1.7.2.6.2.2">
                    <p id="section-toc.1-1.7.2.6.2.2.1"><a href="#section-7.6.2" class="xref">7.6.2</a>.  <a href="#name-establishing-persistent-con" class="xref">Establishing Persistent Congestion</a><a href="#section-toc.1-1.7.2.6.2.2.1" class="pilcrow">¶</a></p>
</li>
                  <li class="compact ulEmpty toc" id="section-toc.1-1.7.2.6.2.3">
                    <p id="section-toc.1-1.7.2.6.2.3.1"><a href="#section-7.6.3" class="xref">7.6.3</a>.  <a href="#name-example" class="xref">Example</a><a href="#section-toc.1-1.7.2.6.2.3.1" class="pilcrow">¶</a></p>
</li>
                </ul>
</li>
              <li class="compact ulEmpty toc" id="section-toc.1-1.7.2.7">
                <p id="section-toc.1-1.7.2.7.1"><a href="#section-7.7" class="xref">7.7</a>.  <a href="#name-pacing" class="xref">Pacing</a><a href="#section-toc.1-1.7.2.7.1" class="pilcrow">¶</a></p>
</li>
              <li class="compact ulEmpty toc" id="section-toc.1-1.7.2.8">
                <p id="section-toc.1-1.7.2.8.1"><a href="#section-7.8" class="xref">7.8</a>.  <a href="#name-under-utilizing-the-congest" class="xref">Under-utilizing the Congestion Window</a><a href="#section-toc.1-1.7.2.8.1" class="pilcrow">¶</a></p>
</li>
            </ul>
</li>
          <li class="compact toc ulEmpty" id="section-toc.1-1.8">
            <p id="section-toc.1-1.8.1"><a href="#section-8" class="xref">8</a>.  <a href="#name-security-considerations" class="xref">Security Considerations</a><a href="#section-toc.1-1.8.1" class="pilcrow">¶</a></p>
<ul class="compact ulEmpty toc">
<li class="compact ulEmpty toc" id="section-toc.1-1.8.2.1">
                <p id="section-toc.1-1.8.2.1.1"><a href="#section-8.1" class="xref">8.1</a>.  <a href="#name-congestion-signals" class="xref">Congestion Signals</a><a href="#section-toc.1-1.8.2.1.1" class="pilcrow">¶</a></p>
</li>
              <li class="compact ulEmpty toc" id="section-toc.1-1.8.2.2">
                <p id="section-toc.1-1.8.2.2.1"><a href="#section-8.2" class="xref">8.2</a>.  <a href="#name-traffic-analysis" class="xref">Traffic Analysis</a><a href="#section-toc.1-1.8.2.2.1" class="pilcrow">¶</a></p>
</li>
              <li class="compact ulEmpty toc" id="section-toc.1-1.8.2.3">
                <p id="section-toc.1-1.8.2.3.1"><a href="#section-8.3" class="xref">8.3</a>.  <a href="#name-misreporting-ecn-markings" class="xref">Misreporting ECN Markings</a><a href="#section-toc.1-1.8.2.3.1" class="pilcrow">¶</a></p>
</li>
            </ul>
</li>
          <li class="compact toc ulEmpty" id="section-toc.1-1.9">
            <p id="section-toc.1-1.9.1"><a href="#section-9" class="xref">9</a>.  <a href="#name-iana-considerations" class="xref">IANA Considerations</a><a href="#section-toc.1-1.9.1" class="pilcrow">¶</a></p>
</li>
          <li class="compact toc ulEmpty" id="section-toc.1-1.10">
            <p id="section-toc.1-1.10.1"><a href="#section-10" class="xref">10</a>. <a href="#name-references" class="xref">References</a><a href="#section-toc.1-1.10.1" class="pilcrow">¶</a></p>
<ul class="compact ulEmpty toc">
<li class="compact ulEmpty toc" id="section-toc.1-1.10.2.1">
                <p id="section-toc.1-1.10.2.1.1"><a href="#section-10.1" class="xref">10.1</a>.  <a href="#name-normative-references" class="xref">Normative References</a><a href="#section-toc.1-1.10.2.1.1" class="pilcrow">¶</a></p>
</li>
              <li class="compact ulEmpty toc" id="section-toc.1-1.10.2.2">
                <p id="section-toc.1-1.10.2.2.1"><a href="#section-10.2" class="xref">10.2</a>.  <a href="#name-informative-references" class="xref">Informative References</a><a href="#section-toc.1-1.10.2.2.1" class="pilcrow">¶</a></p>
</li>
            </ul>
</li>
          <li class="compact toc ulEmpty" id="section-toc.1-1.11">
            <p id="section-toc.1-1.11.1"><a href="#section-appendix.a" class="xref">Appendix A</a>.  <a href="#name-loss-recovery-pseudocode" class="xref">Loss Recovery Pseudocode</a><a href="#section-toc.1-1.11.1" class="pilcrow">¶</a></p>
<ul class="compact ulEmpty toc">
<li class="compact ulEmpty toc" id="section-toc.1-1.11.2.1">
                <p id="section-toc.1-1.11.2.1.1"><a href="#section-a.1" class="xref">A.1</a>.  <a href="#name-tracking-sent-packets" class="xref">Tracking Sent Packets</a><a href="#section-toc.1-1.11.2.1.1" class="pilcrow">¶</a></p>
<ul class="compact ulEmpty toc">
<li class="compact ulEmpty toc" id="section-toc.1-1.11.2.1.2.1">
                    <p id="section-toc.1-1.11.2.1.2.1.1"><a href="#section-a.1.1" class="xref">A.1.1</a>.  <a href="#name-sent-packet-fields" class="xref">Sent Packet Fields</a><a href="#section-toc.1-1.11.2.1.2.1.1" class="pilcrow">¶</a></p>
</li>
                </ul>
</li>
              <li class="compact ulEmpty toc" id="section-toc.1-1.11.2.2">
                <p id="section-toc.1-1.11.2.2.1"><a href="#section-a.2" class="xref">A.2</a>.  <a href="#name-constants-of-interest" class="xref">Constants of Interest</a><a href="#section-toc.1-1.11.2.2.1" class="pilcrow">¶</a></p>
</li>
              <li class="compact ulEmpty toc" id="section-toc.1-1.11.2.3">
                <p id="section-toc.1-1.11.2.3.1"><a href="#section-a.3" class="xref">A.3</a>.  <a href="#name-variables-of-interest" class="xref">Variables of interest</a><a href="#section-toc.1-1.11.2.3.1" class="pilcrow">¶</a></p>
</li>
              <li class="compact ulEmpty toc" id="section-toc.1-1.11.2.4">
                <p id="section-toc.1-1.11.2.4.1"><a href="#section-a.4" class="xref">A.4</a>.  <a href="#name-initialization" class="xref">Initialization</a><a href="#section-toc.1-1.11.2.4.1" class="pilcrow">¶</a></p>
</li>
              <li class="compact ulEmpty toc" id="section-toc.1-1.11.2.5">
                <p id="section-toc.1-1.11.2.5.1"><a href="#section-a.5" class="xref">A.5</a>.  <a href="#name-on-sending-a-packet" class="xref">On Sending a Packet</a><a href="#section-toc.1-1.11.2.5.1" class="pilcrow">¶</a></p>
</li>
              <li class="compact ulEmpty toc" id="section-toc.1-1.11.2.6">
                <p id="section-toc.1-1.11.2.6.1"><a href="#section-a.6" class="xref">A.6</a>.  <a href="#name-on-receiving-a-datagram" class="xref">On Receiving a Datagram</a><a href="#section-toc.1-1.11.2.6.1" class="pilcrow">¶</a></p>
</li>
              <li class="compact ulEmpty toc" id="section-toc.1-1.11.2.7">
                <p id="section-toc.1-1.11.2.7.1"><a href="#section-a.7" class="xref">A.7</a>.  <a href="#name-on-receiving-an-acknowledgm" class="xref">On Receiving an Acknowledgment</a><a href="#section-toc.1-1.11.2.7.1" class="pilcrow">¶</a></p>
</li>
              <li class="compact ulEmpty toc" id="section-toc.1-1.11.2.8">
                <p id="section-toc.1-1.11.2.8.1"><a href="#section-a.8" class="xref">A.8</a>.  <a href="#name-setting-the-loss-detection-" class="xref">Setting the Loss Detection Timer</a><a href="#section-toc.1-1.11.2.8.1" class="pilcrow">¶</a></p>
</li>
              <li class="compact ulEmpty toc" id="section-toc.1-1.11.2.9">
                <p id="section-toc.1-1.11.2.9.1"><a href="#section-a.9" class="xref">A.9</a>.  <a href="#name-on-timeout" class="xref">On Timeout</a><a href="#section-toc.1-1.11.2.9.1" class="pilcrow">¶</a></p>
</li>
              <li class="compact ulEmpty toc" id="section-toc.1-1.11.2.10">
                <p id="section-toc.1-1.11.2.10.1"><a href="#section-a.10" class="xref">A.10</a>. <a href="#name-detecting-lost-packets" class="xref">Detecting Lost Packets</a><a href="#section-toc.1-1.11.2.10.1" class="pilcrow">¶</a></p>
</li>
              <li class="compact ulEmpty toc" id="section-toc.1-1.11.2.11">
                <p id="section-toc.1-1.11.2.11.1"><a href="#section-a.11" class="xref">A.11</a>. <a href="#name-upon-dropping-initial-or-ha" class="xref">Upon Dropping Initial or Handshake Keys</a><a href="#section-toc.1-1.11.2.11.1" class="pilcrow">¶</a></p>
</li>
            </ul>
</li>
          <li class="compact toc ulEmpty" id="section-toc.1-1.12">
            <p id="section-toc.1-1.12.1"><a href="#section-appendix.b" class="xref">Appendix B</a>.  <a href="#name-congestion-control-pseudoco" class="xref">Congestion Control Pseudocode</a><a href="#section-toc.1-1.12.1" class="pilcrow">¶</a></p>
<ul class="compact ulEmpty toc">
<li class="compact ulEmpty toc" id="section-toc.1-1.12.2.1">
                <p id="section-toc.1-1.12.2.1.1"><a href="#section-b.1" class="xref">B.1</a>.  <a href="#name-constants-of-interest-2" class="xref">Constants of interest</a><a href="#section-toc.1-1.12.2.1.1" class="pilcrow">¶</a></p>
</li>
              <li class="compact ulEmpty toc" id="section-toc.1-1.12.2.2">
                <p id="section-toc.1-1.12.2.2.1"><a href="#section-b.2" class="xref">B.2</a>.  <a href="#name-variables-of-interest-2" class="xref">Variables of interest</a><a href="#section-toc.1-1.12.2.2.1" class="pilcrow">¶</a></p>
</li>
              <li class="compact ulEmpty toc" id="section-toc.1-1.12.2.3">
                <p id="section-toc.1-1.12.2.3.1"><a href="#section-b.3" class="xref">B.3</a>.  <a href="#name-initialization-2" class="xref">Initialization</a><a href="#section-toc.1-1.12.2.3.1" class="pilcrow">¶</a></p>
</li>
              <li class="compact ulEmpty toc" id="section-toc.1-1.12.2.4">
                <p id="section-toc.1-1.12.2.4.1"><a href="#section-b.4" class="xref">B.4</a>.  <a href="#name-on-packet-sent" class="xref">On Packet Sent</a><a href="#section-toc.1-1.12.2.4.1" class="pilcrow">¶</a></p>
</li>
              <li class="compact ulEmpty toc" id="section-toc.1-1.12.2.5">
                <p id="section-toc.1-1.12.2.5.1"><a href="#section-b.5" class="xref">B.5</a>.  <a href="#name-on-packet-acknowledgement" class="xref">On Packet Acknowledgement</a><a href="#section-toc.1-1.12.2.5.1" class="pilcrow">¶</a></p>
</li>
              <li class="compact ulEmpty toc" id="section-toc.1-1.12.2.6">
                <p id="section-toc.1-1.12.2.6.1"><a href="#section-b.6" class="xref">B.6</a>.  <a href="#name-on-new-congestion-event" class="xref">On New Congestion Event</a><a href="#section-toc.1-1.12.2.6.1" class="pilcrow">¶</a></p>
</li>
              <li class="compact ulEmpty toc" id="section-toc.1-1.12.2.7">
                <p id="section-toc.1-1.12.2.7.1"><a href="#section-b.7" class="xref">B.7</a>.  <a href="#name-process-ecn-information" class="xref">Process ECN Information</a><a href="#section-toc.1-1.12.2.7.1" class="pilcrow">¶</a></p>
</li>
              <li class="compact ulEmpty toc" id="section-toc.1-1.12.2.8">
                <p id="section-toc.1-1.12.2.8.1"><a href="#section-b.8" class="xref">B.8</a>.  <a href="#name-on-packets-lost" class="xref">On Packets Lost</a><a href="#section-toc.1-1.12.2.8.1" class="pilcrow">¶</a></p>
</li>
              <li class="compact ulEmpty toc" id="section-toc.1-1.12.2.9">
                <p id="section-toc.1-1.12.2.9.1"><a href="#section-b.9" class="xref">B.9</a>.  <a href="#name-removing-discarded-packets-" class="xref">Removing Discarded Packets From Bytes In Flight</a><a href="#section-toc.1-1.12.2.9.1" class="pilcrow">¶</a></p>
</li>
            </ul>
</li>
          <li class="compact toc ulEmpty" id="section-toc.1-1.13">
            <p id="section-toc.1-1.13.1"><a href="#section-appendix.c" class="xref">Appendix C</a>.  <a href="#name-change-log" class="xref">Change Log</a><a href="#section-toc.1-1.13.1" class="pilcrow">¶</a></p>
<ul class="compact ulEmpty toc">
<li class="compact ulEmpty toc" id="section-toc.1-1.13.2.1">
                <p id="section-toc.1-1.13.2.1.1"><a href="#section-c.1" class="xref">C.1</a>.  <a href="#name-since-draft-ietf-quic-recov" class="xref">Since draft-ietf-quic-recovery-31</a><a href="#section-toc.1-1.13.2.1.1" class="pilcrow">¶</a></p>
</li>
              <li class="compact ulEmpty toc" id="section-toc.1-1.13.2.2">
                <p id="section-toc.1-1.13.2.2.1"><a href="#section-c.2" class="xref">C.2</a>.  <a href="#name-since-draft-ietf-quic-recove" class="xref">Since draft-ietf-quic-recovery-30</a><a href="#section-toc.1-1.13.2.2.1" class="pilcrow">¶</a></p>
</li>
              <li class="compact ulEmpty toc" id="section-toc.1-1.13.2.3">
                <p id="section-toc.1-1.13.2.3.1"><a href="#section-c.3" class="xref">C.3</a>.  <a href="#name-since-draft-ietf-quic-recover" class="xref">Since draft-ietf-quic-recovery-29</a><a href="#section-toc.1-1.13.2.3.1" class="pilcrow">¶</a></p>
</li>
              <li class="compact ulEmpty toc" id="section-toc.1-1.13.2.4">
                <p id="section-toc.1-1.13.2.4.1"><a href="#section-c.4" class="xref">C.4</a>.  <a href="#name-since-draft-ietf-quic-recovery" class="xref">Since draft-ietf-quic-recovery-28</a><a href="#section-toc.1-1.13.2.4.1" class="pilcrow">¶</a></p>
</li>
              <li class="compact ulEmpty toc" id="section-toc.1-1.13.2.5">
                <p id="section-toc.1-1.13.2.5.1"><a href="#section-c.5" class="xref">C.5</a>.  <a href="#name-since-draft-ietf-quic-recovery-" class="xref">Since draft-ietf-quic-recovery-27</a><a href="#section-toc.1-1.13.2.5.1" class="pilcrow">¶</a></p>
</li>
              <li class="compact ulEmpty toc" id="section-toc.1-1.13.2.6">
                <p id="section-toc.1-1.13.2.6.1"><a href="#section-c.6" class="xref">C.6</a>.  <a href="#name-since-draft-ietf-quic-recovery-2" class="xref">Since draft-ietf-quic-recovery-26</a><a href="#section-toc.1-1.13.2.6.1" class="pilcrow">¶</a></p>
</li>
              <li class="compact ulEmpty toc" id="section-toc.1-1.13.2.7">
                <p id="section-toc.1-1.13.2.7.1"><a href="#section-c.7" class="xref">C.7</a>.  <a href="#name-since-draft-ietf-quic-recovery-25" class="xref">Since draft-ietf-quic-recovery-25</a><a href="#section-toc.1-1.13.2.7.1" class="pilcrow">¶</a></p>
</li>
              <li class="compact ulEmpty toc" id="section-toc.1-1.13.2.8">
                <p id="section-toc.1-1.13.2.8.1"><a href="#section-c.8" class="xref">C.8</a>.  <a href="#name-since-draft-ietf-quic-recovery-24" class="xref">Since draft-ietf-quic-recovery-24</a><a href="#section-toc.1-1.13.2.8.1" class="pilcrow">¶</a></p>
</li>
              <li class="compact ulEmpty toc" id="section-toc.1-1.13.2.9">
                <p id="section-toc.1-1.13.2.9.1"><a href="#section-c.9" class="xref">C.9</a>.  <a href="#name-since-draft-ietf-quic-recovery-23" class="xref">Since draft-ietf-quic-recovery-23</a><a href="#section-toc.1-1.13.2.9.1" class="pilcrow">¶</a></p>
</li>
              <li class="compact ulEmpty toc" id="section-toc.1-1.13.2.10">
                <p id="section-toc.1-1.13.2.10.1"><a href="#section-c.10" class="xref">C.10</a>. <a href="#name-since-draft-ietf-quic-recovery-22" class="xref">Since draft-ietf-quic-recovery-22</a><a href="#section-toc.1-1.13.2.10.1" class="pilcrow">¶</a></p>
</li>
              <li class="compact ulEmpty toc" id="section-toc.1-1.13.2.11">
                <p id="section-toc.1-1.13.2.11.1"><a href="#section-c.11" class="xref">C.11</a>. <a href="#name-since-draft-ietf-quic-recovery-21" class="xref">Since draft-ietf-quic-recovery-21</a><a href="#section-toc.1-1.13.2.11.1" class="pilcrow">¶</a></p>
</li>
              <li class="compact ulEmpty toc" id="section-toc.1-1.13.2.12">
                <p id="section-toc.1-1.13.2.12.1"><a href="#section-c.12" class="xref">C.12</a>. <a href="#name-since-draft-ietf-quic-recovery-20" class="xref">Since draft-ietf-quic-recovery-20</a><a href="#section-toc.1-1.13.2.12.1" class="pilcrow">¶</a></p>
</li>
              <li class="compact ulEmpty toc" id="section-toc.1-1.13.2.13">
                <p id="section-toc.1-1.13.2.13.1"><a href="#section-c.13" class="xref">C.13</a>. <a href="#name-since-draft-ietf-quic-recovery-1" class="xref">Since draft-ietf-quic-recovery-19</a><a href="#section-toc.1-1.13.2.13.1" class="pilcrow">¶</a></p>
</li>
              <li class="compact ulEmpty toc" id="section-toc.1-1.13.2.14">
                <p id="section-toc.1-1.13.2.14.1"><a href="#section-c.14" class="xref">C.14</a>. <a href="#name-since-draft-ietf-quic-recovery-18" class="xref">Since draft-ietf-quic-recovery-18</a><a href="#section-toc.1-1.13.2.14.1" class="pilcrow">¶</a></p>
</li>
              <li class="compact ulEmpty toc" id="section-toc.1-1.13.2.15">
                <p id="section-toc.1-1.13.2.15.1"><a href="#section-c.15" class="xref">C.15</a>. <a href="#name-since-draft-ietf-quic-recovery-17" class="xref">Since draft-ietf-quic-recovery-17</a><a href="#section-toc.1-1.13.2.15.1" class="pilcrow">¶</a></p>
</li>
              <li class="compact ulEmpty toc" id="section-toc.1-1.13.2.16">
                <p id="section-toc.1-1.13.2.16.1"><a href="#section-c.16" class="xref">C.16</a>. <a href="#name-since-draft-ietf-quic-recovery-16" class="xref">Since draft-ietf-quic-recovery-16</a><a href="#section-toc.1-1.13.2.16.1" class="pilcrow">¶</a></p>
</li>
              <li class="compact ulEmpty toc" id="section-toc.1-1.13.2.17">
                <p id="section-toc.1-1.13.2.17.1"><a href="#section-c.17" class="xref">C.17</a>. <a href="#name-since-draft-ietf-quic-recovery-14" class="xref">Since draft-ietf-quic-recovery-14</a><a href="#section-toc.1-1.13.2.17.1" class="pilcrow">¶</a></p>
</li>
              <li class="compact ulEmpty toc" id="section-toc.1-1.13.2.18">
                <p id="section-toc.1-1.13.2.18.1"><a href="#section-c.18" class="xref">C.18</a>. <a href="#name-since-draft-ietf-quic-recovery-13" class="xref">Since draft-ietf-quic-recovery-13</a><a href="#section-toc.1-1.13.2.18.1" class="pilcrow">¶</a></p>
</li>
              <li class="compact ulEmpty toc" id="section-toc.1-1.13.2.19">
                <p id="section-toc.1-1.13.2.19.1"><a href="#section-c.19" class="xref">C.19</a>. <a href="#name-since-draft-ietf-quic-recovery-12" class="xref">Since draft-ietf-quic-recovery-12</a><a href="#section-toc.1-1.13.2.19.1" class="pilcrow">¶</a></p>
</li>
              <li class="compact ulEmpty toc" id="section-toc.1-1.13.2.20">
                <p id="section-toc.1-1.13.2.20.1"><a href="#section-c.20" class="xref">C.20</a>. <a href="#name-since-draft-ietf-quic-recovery-11" class="xref">Since draft-ietf-quic-recovery-11</a><a href="#section-toc.1-1.13.2.20.1" class="pilcrow">¶</a></p>
</li>
              <li class="compact ulEmpty toc" id="section-toc.1-1.13.2.21">
                <p id="section-toc.1-1.13.2.21.1"><a href="#section-c.21" class="xref">C.21</a>. <a href="#name-since-draft-ietf-quic-recovery-10" class="xref">Since draft-ietf-quic-recovery-10</a><a href="#section-toc.1-1.13.2.21.1" class="pilcrow">¶</a></p>
</li>
              <li class="compact ulEmpty toc" id="section-toc.1-1.13.2.22">
                <p id="section-toc.1-1.13.2.22.1"><a href="#section-c.22" class="xref">C.22</a>. <a href="#name-since-draft-ietf-quic-recovery-0" class="xref">Since draft-ietf-quic-recovery-09</a><a href="#section-toc.1-1.13.2.22.1" class="pilcrow">¶</a></p>
</li>
              <li class="compact ulEmpty toc" id="section-toc.1-1.13.2.23">
                <p id="section-toc.1-1.13.2.23.1"><a href="#section-c.23" class="xref">C.23</a>. <a href="#name-since-draft-ietf-quic-recovery-08" class="xref">Since draft-ietf-quic-recovery-08</a><a href="#section-toc.1-1.13.2.23.1" class="pilcrow">¶</a></p>
</li>
              <li class="compact ulEmpty toc" id="section-toc.1-1.13.2.24">
                <p id="section-toc.1-1.13.2.24.1"><a href="#section-c.24" class="xref">C.24</a>. <a href="#name-since-draft-ietf-quic-recovery-07" class="xref">Since draft-ietf-quic-recovery-07</a><a href="#section-toc.1-1.13.2.24.1" class="pilcrow">¶</a></p>
</li>
              <li class="compact ulEmpty toc" id="section-toc.1-1.13.2.25">
                <p id="section-toc.1-1.13.2.25.1"><a href="#section-c.25" class="xref">C.25</a>. <a href="#name-since-draft-ietf-quic-recovery-06" class="xref">Since draft-ietf-quic-recovery-06</a><a href="#section-toc.1-1.13.2.25.1" class="pilcrow">¶</a></p>
</li>
              <li class="compact ulEmpty toc" id="section-toc.1-1.13.2.26">
                <p id="section-toc.1-1.13.2.26.1"><a href="#section-c.26" class="xref">C.26</a>. <a href="#name-since-draft-ietf-quic-recovery-05" class="xref">Since draft-ietf-quic-recovery-05</a><a href="#section-toc.1-1.13.2.26.1" class="pilcrow">¶</a></p>
</li>
              <li class="compact ulEmpty toc" id="section-toc.1-1.13.2.27">
                <p id="section-toc.1-1.13.2.27.1"><a href="#section-c.27" class="xref">C.27</a>. <a href="#name-since-draft-ietf-quic-recovery-04" class="xref">Since draft-ietf-quic-recovery-04</a><a href="#section-toc.1-1.13.2.27.1" class="pilcrow">¶</a></p>
</li>
              <li class="compact ulEmpty toc" id="section-toc.1-1.13.2.28">
                <p id="section-toc.1-1.13.2.28.1"><a href="#section-c.28" class="xref">C.28</a>. <a href="#name-since-draft-ietf-quic-recovery-03" class="xref">Since draft-ietf-quic-recovery-03</a><a href="#section-toc.1-1.13.2.28.1" class="pilcrow">¶</a></p>
</li>
              <li class="compact ulEmpty toc" id="section-toc.1-1.13.2.29">
                <p id="section-toc.1-1.13.2.29.1"><a href="#section-c.29" class="xref">C.29</a>. <a href="#name-since-draft-ietf-quic-recovery-02" class="xref">Since draft-ietf-quic-recovery-02</a><a href="#section-toc.1-1.13.2.29.1" class="pilcrow">¶</a></p>
</li>
              <li class="compact ulEmpty toc" id="section-toc.1-1.13.2.30">
                <p id="section-toc.1-1.13.2.30.1"><a href="#section-c.30" class="xref">C.30</a>. <a href="#name-since-draft-ietf-quic-recovery-01" class="xref">Since draft-ietf-quic-recovery-01</a><a href="#section-toc.1-1.13.2.30.1" class="pilcrow">¶</a></p>
</li>
              <li class="compact ulEmpty toc" id="section-toc.1-1.13.2.31">
                <p id="section-toc.1-1.13.2.31.1"><a href="#section-c.31" class="xref">C.31</a>. <a href="#name-since-draft-ietf-quic-recovery-00" class="xref">Since draft-ietf-quic-recovery-00</a><a href="#section-toc.1-1.13.2.31.1" class="pilcrow">¶</a></p>
</li>
              <li class="compact ulEmpty toc" id="section-toc.1-1.13.2.32">
                <p id="section-toc.1-1.13.2.32.1"><a href="#section-c.32" class="xref">C.32</a>. <a href="#name-since-draft-iyengar-quic-lo" class="xref">Since draft-iyengar-quic-loss-recovery-01</a><a href="#section-toc.1-1.13.2.32.1" class="pilcrow">¶</a></p>
</li>
            </ul>
</li>
          <li class="compact toc ulEmpty" id="section-toc.1-1.14">
            <p id="section-toc.1-1.14.1"><a href="#section-appendix.d" class="xref">Appendix D</a>.  <a href="#name-contributors" class="xref">Contributors</a><a href="#section-toc.1-1.14.1" class="pilcrow">¶</a></p>
</li>
          <li class="compact toc ulEmpty" id="section-toc.1-1.15">
            <p id="section-toc.1-1.15.1"><a href="#section-appendix.e" class="xref"></a><a href="#name-acknowledgments" class="xref">Acknowledgments</a><a href="#section-toc.1-1.15.1" class="pilcrow">¶</a></p>
</li>
          <li class="compact toc ulEmpty" id="section-toc.1-1.16">
            <p id="section-toc.1-1.16.1"><a href="#section-appendix.f" class="xref"></a><a href="#name-authors-addresses" class="xref">Authors' Addresses</a><a href="#section-toc.1-1.16.1" class="pilcrow">¶</a></p>
</li>
        </ul>
</nav>
</section>
</div>
<div id="introduction">
<section id="section-1">
      <h2 id="name-introduction">
<a href="#section-1" class="section-number selfRef">1. </a><a href="#name-introduction" class="section-name selfRef">Introduction</a>
      </h2>
<p id="section-1-1">QUIC is a new multiplexed and secure transport protocol atop UDP, specified in
<span>[<a href="#QUIC-TRANSPORT" class="xref">QUIC-TRANSPORT</a>]</span>. This document describes congestion control and loss
recovery for QUIC. Mechanisms described in this document follow the spirit
of existing TCP congestion control and loss recovery mechanisms, described in
RFCs, various Internet-drafts, or academic papers, and also those prevalent in
TCP implementations.<a href="#section-1-1" class="pilcrow">¶</a></p>
</section>
</div>
<div id="conventions-and-definitions">
<section id="section-2">
      <h2 id="name-conventions-and-definitions">
<a href="#section-2" class="section-number selfRef">2. </a><a href="#name-conventions-and-definitions" class="section-name selfRef">Conventions and Definitions</a>
      </h2>
<p id="section-2-1">The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL
NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED",
"MAY", and "OPTIONAL" in this document are to be interpreted as
described in BCP 14 <span>[<a href="#RFC2119" class="xref">RFC2119</a>]</span> <span>[<a href="#RFC8174" class="xref">RFC8174</a>]</span> when, and only when, they
appear in all capitals, as shown here.<a href="#section-2-1" class="pilcrow">¶</a></p>
<p id="section-2-2">Definitions of terms that are used in this document:<a href="#section-2-2" class="pilcrow">¶</a></p>
<span class="break"></span><dl class="dlParallel" id="section-2-3">
        <dt id="section-2-3.1">Ack-eliciting frames:</dt>
        <dd style="margin-left: 1.5em" id="section-2-3.2">
  All frames other than ACK, PADDING, and CONNECTION_CLOSE are considered
ack-eliciting.<a href="#section-2-3.2" class="pilcrow">¶</a>
</dd>
        <dd class="break"></dd>
<dt id="section-2-3.3">Ack-eliciting packets:</dt>
        <dd style="margin-left: 1.5em" id="section-2-3.4">
  Packets that contain ack-eliciting frames elicit an ACK from the receiver
within the maximum acknowledgement delay and are called ack-eliciting packets.<a href="#section-2-3.4" class="pilcrow">¶</a>
</dd>
        <dd class="break"></dd>
<dt id="section-2-3.5">In-flight:</dt>
        <dd style="margin-left: 1.5em" id="section-2-3.6">
  Packets are considered in-flight when they are ack-eliciting or contain a
PADDING frame, and they have been sent but are not acknowledged, declared
lost, or discarded along with old keys.<a href="#section-2-3.6" class="pilcrow">¶</a>
</dd>
      <dd class="break"></dd>
</dl>
</section>
</div>
<div id="design-of-the-quic-transmission-machinery">
<section id="section-3">
      <h2 id="name-design-of-the-quic-transmis">
<a href="#section-3" class="section-number selfRef">3. </a><a href="#name-design-of-the-quic-transmis" class="section-name selfRef">Design of the QUIC Transmission Machinery</a>
      </h2>
<p id="section-3-1">All transmissions in QUIC are sent with a packet-level header, which indicates
the encryption level and includes a packet sequence number (referred to below as
a packet number).  The encryption level indicates the packet number space, as
described in <span>[<a href="#QUIC-TRANSPORT" class="xref">QUIC-TRANSPORT</a>]</span>.  Packet numbers never repeat within a packet
number space for the lifetime of a connection.  Packet numbers are sent in
monotonically increasing order within a space, preventing ambiguity.<a href="#section-3-1" class="pilcrow">¶</a></p>
<p id="section-3-2">This design obviates the need for disambiguating between transmissions and
retransmissions; this eliminates significant complexity from QUIC's
interpretation of TCP loss detection mechanisms.<a href="#section-3-2" class="pilcrow">¶</a></p>
<p id="section-3-3">QUIC packets can contain multiple frames of different types. The recovery
mechanisms ensure that data and frames that need reliable delivery are
acknowledged or declared lost and sent in new packets as necessary. The types
of frames contained in a packet affect recovery and congestion control logic:<a href="#section-3-3" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="section-3-4.1">All packets are acknowledged, though packets that contain no
ack-eliciting frames are only acknowledged along with ack-eliciting
packets.<a href="#section-3-4.1" class="pilcrow">¶</a>
</li>
        <li class="normal" id="section-3-4.2">Long header packets that contain CRYPTO frames are critical to the
performance of the QUIC handshake and use shorter timers for
acknowledgement.<a href="#section-3-4.2" class="pilcrow">¶</a>
</li>
        <li class="normal" id="section-3-4.3">Packets containing frames besides ACK or CONNECTION_CLOSE frames count toward
congestion control limits and are considered in-flight.<a href="#section-3-4.3" class="pilcrow">¶</a>
</li>
        <li class="normal" id="section-3-4.4">PADDING frames cause packets to contribute toward bytes in flight without
directly causing an acknowledgment to be sent.<a href="#section-3-4.4" class="pilcrow">¶</a>
</li>
      </ul>
</section>
</div>
<div id="relevant-differences-between-quic-and-tcp">
<section id="section-4">
      <h2 id="name-relevant-differences-betwee">
<a href="#section-4" class="section-number selfRef">4. </a><a href="#name-relevant-differences-betwee" class="section-name selfRef">Relevant Differences Between QUIC and TCP</a>
      </h2>
<p id="section-4-1">Readers familiar with TCP's loss detection and congestion control will find
algorithms here that parallel well-known TCP ones. However, protocol differences
between QUIC and TCP contribute to algorithmic differences. These protocol
differences are briefly described below.<a href="#section-4-1" class="pilcrow">¶</a></p>
<div id="separate-packet-number-spaces">
<section id="section-4.1">
        <h3 id="name-separate-packet-number-spac">
<a href="#section-4.1" class="section-number selfRef">4.1. </a><a href="#name-separate-packet-number-spac" class="section-name selfRef">Separate Packet Number Spaces</a>
        </h3>
<p id="section-4.1-1">QUIC uses separate packet number spaces for each encryption level, except 0-RTT
and all generations of 1-RTT keys use the same packet number space.  Separate
packet number spaces ensures acknowledgement of packets sent with one level of
encryption will not cause spurious retransmission of packets sent with a
different encryption level.  Congestion control and round-trip time (RTT)
measurement are unified across packet number spaces.<a href="#section-4.1-1" class="pilcrow">¶</a></p>
</section>
</div>
<div id="monotonically-increasing-packet-numbers">
<section id="section-4.2">
        <h3 id="name-monotonically-increasing-pa">
<a href="#section-4.2" class="section-number selfRef">4.2. </a><a href="#name-monotonically-increasing-pa" class="section-name selfRef">Monotonically Increasing Packet Numbers</a>
        </h3>
<p id="section-4.2-1">TCP conflates transmission order at the sender with delivery order at the
receiver, which results in retransmissions of the same data carrying the same
sequence number, and consequently leads to "retransmission ambiguity".  QUIC
separates the two. QUIC uses a packet number to indicate transmission order.
Application data is sent in one or more streams and delivery order is
determined by stream offsets encoded within STREAM frames.<a href="#section-4.2-1" class="pilcrow">¶</a></p>
<p id="section-4.2-2">QUIC's packet number is strictly increasing within a packet number space,
and directly encodes transmission order.  A higher packet number signifies
that the packet was sent later, and a lower packet number signifies that
the packet was sent earlier.  When a packet containing ack-eliciting
frames is detected lost, QUIC includes necessary frames in a new packet
with a new packet number, removing ambiguity about which packet is
acknowledged when an ACK is received.  Consequently, more accurate RTT
measurements can be made, spurious retransmissions are trivially detected, and
mechanisms such as Fast Retransmit can be applied universally, based only on
packet number.<a href="#section-4.2-2" class="pilcrow">¶</a></p>
<p id="section-4.2-3">This design point significantly simplifies loss detection mechanisms for QUIC.
Most TCP mechanisms implicitly attempt to infer transmission ordering based on
TCP sequence numbers - a non-trivial task, especially when TCP timestamps are
not available.<a href="#section-4.2-3" class="pilcrow">¶</a></p>
</section>
</div>
<div id="clearer-loss-epoch">
<section id="section-4.3">
        <h3 id="name-clearer-loss-epoch">
<a href="#section-4.3" class="section-number selfRef">4.3. </a><a href="#name-clearer-loss-epoch" class="section-name selfRef">Clearer Loss Epoch</a>
        </h3>
<p id="section-4.3-1">QUIC starts a loss epoch when a packet is lost. The loss epoch ends when any
packet sent after the start of the epoch is acknowledged.  TCP waits for the gap
in the sequence number space to be filled, and so if a segment is lost multiple
times in a row, the loss epoch may not end for several round trips. Because both
should reduce their congestion windows only once per epoch, QUIC will do it once
for every round trip that experiences loss, while TCP may only do it once across
multiple round trips.<a href="#section-4.3-1" class="pilcrow">¶</a></p>
</section>
</div>
<div id="no-reneging">
<section id="section-4.4">
        <h3 id="name-no-reneging">
<a href="#section-4.4" class="section-number selfRef">4.4. </a><a href="#name-no-reneging" class="section-name selfRef">No Reneging</a>
        </h3>
<p id="section-4.4-1">QUIC ACKs contain information that is similar to TCP SACK, but QUIC does not
allow any acknowledged packet to be reneged, greatly simplifying implementations
on both sides and reducing memory pressure on the sender.<a href="#section-4.4-1" class="pilcrow">¶</a></p>
</section>
</div>
<div id="more-ack-ranges">
<section id="section-4.5">
        <h3 id="name-more-ack-ranges">
<a href="#section-4.5" class="section-number selfRef">4.5. </a><a href="#name-more-ack-ranges" class="section-name selfRef">More ACK Ranges</a>
        </h3>
<p id="section-4.5-1">QUIC supports many ACK ranges, opposed to TCP's 3 SACK ranges.  In high loss
environments, this speeds recovery, reduces spurious retransmits, and ensures
forward progress without relying on timeouts.<a href="#section-4.5-1" class="pilcrow">¶</a></p>
</section>
</div>
<div id="explicit-correction-for-delayed-acknowledgements">
<section id="section-4.6">
        <h3 id="name-explicit-correction-for-del">
<a href="#section-4.6" class="section-number selfRef">4.6. </a><a href="#name-explicit-correction-for-del" class="section-name selfRef">Explicit Correction For Delayed Acknowledgements</a>
        </h3>
<p id="section-4.6-1">QUIC endpoints measure the delay incurred between when a packet is received and
when the corresponding acknowledgment is sent, allowing a peer to maintain a
more accurate round-trip time estimate; see Section 13.2 of <span>[<a href="#QUIC-TRANSPORT" class="xref">QUIC-TRANSPORT</a>]</span>.<a href="#section-4.6-1" class="pilcrow">¶</a></p>
</section>
</div>
<div id="probe-timeout-replaces-rto-and-tlp">
<section id="section-4.7">
        <h3 id="name-probe-timeout-replaces-rto-">
<a href="#section-4.7" class="section-number selfRef">4.7. </a><a href="#name-probe-timeout-replaces-rto-" class="section-name selfRef">Probe Timeout Replaces RTO and TLP</a>
        </h3>
<p id="section-4.7-1">QUIC uses a probe timeout (PTO; see <a href="#pto" class="xref">Section 6.2</a>), with a timer based on TCP's RTO
computation.  QUIC's PTO includes the peer's maximum expected acknowledgement
delay instead of using a fixed minimum timeout. QUIC does not collapse the
congestion window until persistent congestion (<a href="#persistent-congestion" class="xref">Section 7.6</a>) is
declared, unlike TCP, which collapses the congestion window upon expiry of an
RTO.  Instead of collapsing the congestion window and declaring everything
in-flight lost, QUIC allows probe packets to temporarily exceed the congestion
window whenever the timer expires.<a href="#section-4.7-1" class="pilcrow">¶</a></p>
<p id="section-4.7-2">In doing this, QUIC avoids unnecessary congestion window reductions, obviating
the need for correcting mechanisms such as F-RTO (<span>[<a href="#RFC5682" class="xref">RFC5682</a>]</span>). Since QUIC does
not collapse the congestion window on a PTO expiration, a QUIC sender is not
limited from sending more in-flight packets after a PTO expiration if it still
has available congestion window. This occurs when a sender is
application-limited and the PTO timer expires. This is more aggressive than
TCP's RTO mechanism when application-limited, but identical when not
application-limited.<a href="#section-4.7-2" class="pilcrow">¶</a></p>
<p id="section-4.7-3">A single packet loss at the tail does not indicate persistent congestion, so
QUIC specifies a time-based definition to ensure one or more packets are sent
prior to a dramatic decrease in congestion window; see
<a href="#persistent-congestion" class="xref">Section 7.6</a>.<a href="#section-4.7-3" class="pilcrow">¶</a></p>
</section>
</div>
<div id="the-minimum-congestion-window-is-two-packets">
<section id="section-4.8">
        <h3 id="name-the-minimum-congestion-wind">
<a href="#section-4.8" class="section-number selfRef">4.8. </a><a href="#name-the-minimum-congestion-wind" class="section-name selfRef">The Minimum Congestion Window is Two Packets</a>
        </h3>
<p id="section-4.8-1">TCP uses a minimum congestion window of one packet. However, loss of
that single packet means that the sender needs to waiting for a PTO
(<a href="#pto" class="xref">Section 6.2</a>) to recover, which can be much longer than a round-trip time.
Sending a single ack-eliciting packet also increases the chances of incurring
additional latency when a receiver delays its acknowledgement.<a href="#section-4.8-1" class="pilcrow">¶</a></p>
<p id="section-4.8-2">QUIC therefore recommends that the minimum congestion window be two
packets. While this increases network load, it is considered safe, since the
sender will still reduce its sending rate exponentially under persistent
congestion (<a href="#pto" class="xref">Section 6.2</a>).<a href="#section-4.8-2" class="pilcrow">¶</a></p>
</section>
</div>
</section>
</div>
<div id="compute-rtt">
<section id="section-5">
      <h2 id="name-estimating-the-round-trip-t">
<a href="#section-5" class="section-number selfRef">5. </a><a href="#name-estimating-the-round-trip-t" class="section-name selfRef">Estimating the Round-Trip Time</a>
      </h2>
<p id="section-5-1">At a high level, an endpoint measures the time from when a packet was sent to
when it is acknowledged as a round-trip time (RTT) sample.  The endpoint uses
RTT samples and peer-reported host delays (see Section 13.2 of
<span>[<a href="#QUIC-TRANSPORT" class="xref">QUIC-TRANSPORT</a>]</span>) to generate a statistical description of the network
path's RTT. An endpoint computes the following three values for each path:
the minimum value observed over the lifetime of the path (min_rtt), an
exponentially-weighted moving average (smoothed_rtt), and the mean deviation
(referred to as "variation" in the rest of this document) in the observed RTT
samples (rttvar).<a href="#section-5-1" class="pilcrow">¶</a></p>
<div id="latest-rtt">
<section id="section-5.1">
        <h3 id="name-generating-rtt-samples">
<a href="#section-5.1" class="section-number selfRef">5.1. </a><a href="#name-generating-rtt-samples" class="section-name selfRef">Generating RTT samples</a>
        </h3>
<p id="section-5.1-1">An endpoint generates an RTT sample on receiving an ACK frame that meets the
following two conditions:<a href="#section-5.1-1" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="section-5.1-2.1">the largest acknowledged packet number is newly acknowledged, and<a href="#section-5.1-2.1" class="pilcrow">¶</a>
</li>
          <li class="normal" id="section-5.1-2.2">at least one of the newly acknowledged packets was ack-eliciting.<a href="#section-5.1-2.2" class="pilcrow">¶</a>
</li>
        </ul>
<p id="section-5.1-3">The RTT sample, latest_rtt, is generated as the time elapsed since the largest
acknowledged packet was sent:<a href="#section-5.1-3" class="pilcrow">¶</a></p>
<div class="artwork art-text alignLeft" id="section-5.1-4">
<pre>
latest_rtt = ack_time - send_time_of_largest_acked
</pre><a href="#section-5.1-4" class="pilcrow">¶</a>
</div>
<p id="section-5.1-5">An RTT sample is generated using only the largest acknowledged packet in the
received ACK frame.  This is because a peer reports acknowledgment delays for
only the largest acknowledged packet in an ACK frame.  While the reported
acknowledgment delay is not used by the RTT sample measurement, it is used to
adjust the RTT sample in subsequent computations of smoothed_rtt and rttvar
(<a href="#smoothed-rtt" class="xref">Section 5.3</a>).<a href="#section-5.1-5" class="pilcrow">¶</a></p>
<p id="section-5.1-6">To avoid generating multiple RTT samples for a single packet, an ACK frame
SHOULD NOT be used to update RTT estimates if it does not newly acknowledge the
largest acknowledged packet.<a href="#section-5.1-6" class="pilcrow">¶</a></p>
<p id="section-5.1-7">An RTT sample MUST NOT be generated on receiving an ACK frame that does not
newly acknowledge at least one ack-eliciting packet. A peer usually does not
send an ACK frame when only non-ack-eliciting packets are received. Therefore
an ACK frame that contains acknowledgements for only non-ack-eliciting packets
could include an arbitrarily large ACK Delay value.  Ignoring
such ACK frames avoids complications in subsequent smoothed_rtt and rttvar
computations.<a href="#section-5.1-7" class="pilcrow">¶</a></p>
<p id="section-5.1-8">A sender might generate multiple RTT samples per RTT when multiple ACK frames
are received within an RTT.  As suggested in <span>[<a href="#RFC6298" class="xref">RFC6298</a>]</span>, doing so might result
in inadequate history in smoothed_rtt and rttvar.  Ensuring that RTT estimates
retain sufficient history is an open research question.<a href="#section-5.1-8" class="pilcrow">¶</a></p>
</section>
</div>
<div id="min-rtt">
<section id="section-5.2">
        <h3 id="name-estimating-min_rtt">
<a href="#section-5.2" class="section-number selfRef">5.2. </a><a href="#name-estimating-min_rtt" class="section-name selfRef">Estimating min_rtt</a>
        </h3>
<p id="section-5.2-1">min_rtt is the sender's estimate of the minimum RTT observed for a given network
path. In this document, min_rtt is used by loss detection to reject implausibly
small rtt samples.<a href="#section-5.2-1" class="pilcrow">¶</a></p>
<p id="section-5.2-2">min_rtt MUST be set to the latest_rtt on the first RTT sample. min_rtt MUST be
set to the lesser of min_rtt and latest_rtt (<a href="#latest-rtt" class="xref">Section 5.1</a>) on all other
samples.<a href="#section-5.2-2" class="pilcrow">¶</a></p>
<p id="section-5.2-3">An endpoint uses only locally observed times in computing the min_rtt and does
not adjust for acknowledgment delays reported by the peer. Doing so allows the
endpoint to set a lower bound for the smoothed_rtt based entirely on what it
observes (see <a href="#smoothed-rtt" class="xref">Section 5.3</a>), and limits potential underestimation due to
erroneously-reported delays by the peer.<a href="#section-5.2-3" class="pilcrow">¶</a></p>
<p id="section-5.2-4">The RTT for a network path may change over time. If a path's actual RTT
decreases, the min_rtt will adapt immediately on the first low sample.  If the
path's actual RTT increases however, the min_rtt will not adapt to it, allowing
future RTT samples that are smaller than the new RTT to be included in
smoothed_rtt.<a href="#section-5.2-4" class="pilcrow">¶</a></p>
<p id="section-5.2-5">Endpoints SHOULD set the min_rtt to the newest RTT sample after persistent
congestion is established. This is to allow a connection to reset its estimate
of min_rtt and smoothed_rtt (<a href="#smoothed-rtt" class="xref">Section 5.3</a>) after a disruptive network event,
and because it is possible that an increase in path delay resulted in persistent
congestion being incorrectly declared.<a href="#section-5.2-5" class="pilcrow">¶</a></p>
<p id="section-5.2-6">Endpoints MAY re-establish the min_rtt at other times in the connection, such as
when traffic volume is low and an acknowledgement is received with a low
acknowledgement delay. Implementations SHOULD NOT refresh the min_rtt
value too often, since the actual minimum RTT of the path is not
frequently observable.<a href="#section-5.2-6" class="pilcrow">¶</a></p>
</section>
</div>
<div id="smoothed-rtt">
<section id="section-5.3">
        <h3 id="name-estimating-smoothed_rtt-and">
<a href="#section-5.3" class="section-number selfRef">5.3. </a><a href="#name-estimating-smoothed_rtt-and" class="section-name selfRef">Estimating smoothed_rtt and rttvar</a>
        </h3>
<p id="section-5.3-1">smoothed_rtt is an exponentially-weighted moving average of an endpoint's RTT
samples, and rttvar is the variation in the RTT samples, estimated using a
mean variation.<a href="#section-5.3-1" class="pilcrow">¶</a></p>
<p id="section-5.3-2">The calculation of smoothed_rtt uses RTT samples after adjusting them for
acknowledgement delays. These delays are decoded from the ACK Delay field of
ACK frames as described in Section 19.3 of <span>[<a href="#QUIC-TRANSPORT" class="xref">QUIC-TRANSPORT</a>]</span>.<a href="#section-5.3-2" class="pilcrow">¶</a></p>
<p id="section-5.3-3">The peer might report acknowledgement delays that are larger than the peer's
max_ack_delay during the handshake (Section 13.2.1 of <span>[<a href="#QUIC-TRANSPORT" class="xref">QUIC-TRANSPORT</a>]</span>). To
account for this, the endpoint SHOULD ignore max_ack_delay until the handshake
is confirmed (Section 4.1.2 of <span>[<a href="#QUIC-TLS" class="xref">QUIC-TLS</a>]</span>). When they occur, these large
acknowledgement delays are likely to be non-repeating and limited to the
handshake. The endpoint can therefore use them without limiting them to the
max_ack_delay, avoiding unnecessary inflation of the RTT estimate.<a href="#section-5.3-3" class="pilcrow">¶</a></p>
<p id="section-5.3-4">Note however that a large acknowledgement delay can result in a substantially
inflated smoothed_rtt, if there is either an error in the peer's reporting of
the acknowledgement delay or in the endpoint's min_rtt estimate.  Therefore,
prior to handshake confirmation, an endpoint MAY ignore RTT samples if adjusting
the RTT sample for acknowledgement delay causes the sample to be less than the
min_rtt.<a href="#section-5.3-4" class="pilcrow">¶</a></p>
<p id="section-5.3-5">After the handshake is confirmed, any acknowledgement delays reported by the
peer that are greater than the peer's max_ack_delay are attributed to
unintentional but potentially repeating delays, such as scheduler latency at the
peer or loss of previous acknowledgements.  Excess delays could also be due to
a non-compliant receiver.  Therefore, these extra delays are considered
effectively part of path delay and incorporated into the RTT estimate.<a href="#section-5.3-5" class="pilcrow">¶</a></p>
<p id="section-5.3-6">Therefore, when adjusting an RTT sample using peer-reported acknowledgement
delays, an endpoint:<a href="#section-5.3-6" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="section-5.3-7.1">MAY ignore the acknowledgement delay for Initial packets, since these
acknowledgements are not delayed by the peer (Section 13.2.1 of
<span>[<a href="#QUIC-TRANSPORT" class="xref">QUIC-TRANSPORT</a>]</span>);<a href="#section-5.3-7.1" class="pilcrow">¶</a>
</li>
          <li class="normal" id="section-5.3-7.2">SHOULD ignore the peer's max_ack_delay until the handshake is confirmed;<a href="#section-5.3-7.2" class="pilcrow">¶</a>
</li>
          <li class="normal" id="section-5.3-7.3">MUST use the lesser of the acknowledgement delay and the peer's max_ack_delay
after the handshake is confirmed; and<a href="#section-5.3-7.3" class="pilcrow">¶</a>
</li>
          <li class="normal" id="section-5.3-7.4">MUST NOT subtract the acknowledgement delay from the RTT sample if the
resulting value is smaller than the min_rtt.  This limits the underestimation
of the smoothed_rtt due to a misreporting peer.<a href="#section-5.3-7.4" class="pilcrow">¶</a>
</li>
        </ul>
<p id="section-5.3-8">Additionally, an endpoint might postpone the processing of acknowledgements when
the corresponding decryption keys are not immediately available. For example, a
client might receive an acknowledgement for a 0-RTT packet that it cannot
decrypt because 1-RTT packet protection keys are not yet available to it. In
such cases, an endpoint SHOULD subtract such local delays from its RTT sample
until the handshake is confirmed.<a href="#section-5.3-8" class="pilcrow">¶</a></p>
<p id="section-5.3-9">Similar to <span>[<a href="#RFC6298" class="xref">RFC6298</a>]</span>, smoothed_rtt and rttvar are computed as follows.<a href="#section-5.3-9" class="pilcrow">¶</a></p>
<p id="section-5.3-10">An endpoint initializes the RTT estimator during connection establishment and
when the estimator is reset during connection migration; see Section 9.4 of
<span>[<a href="#QUIC-TRANSPORT" class="xref">QUIC-TRANSPORT</a>]</span>. Before any RTT samples are available for a new path or when
the estimator is reset, the estimator is initialized using the initial RTT; see
<a href="#pto-handshake" class="xref">Section 6.2.2</a>.<a href="#section-5.3-10" class="pilcrow">¶</a></p>
<p id="section-5.3-11">smoothed_rtt and rttvar are initialized as follows, where kInitialRtt contains
the initial RTT value:<a href="#section-5.3-11" class="pilcrow">¶</a></p>
<div class="artwork art-text alignLeft" id="section-5.3-12">
<pre>
smoothed_rtt = kInitialRtt
rttvar = kInitialRtt / 2
</pre><a href="#section-5.3-12" class="pilcrow">¶</a>
</div>
<p id="section-5.3-13">RTT samples for the network path are recorded in latest_rtt; see
<a href="#latest-rtt" class="xref">Section 5.1</a>. On the first RTT sample after initialization, the estimator is
reset using that sample. This ensures that the estimator retains no history of
past samples.<a href="#section-5.3-13" class="pilcrow">¶</a></p>
<p id="section-5.3-14">On the first RTT sample after initialization, smoothed_rtt and rttvar are set as
follows:<a href="#section-5.3-14" class="pilcrow">¶</a></p>
<div class="artwork art-text alignLeft" id="section-5.3-15">
<pre>
smoothed_rtt = latest_rtt
rttvar = latest_rtt / 2
</pre><a href="#section-5.3-15" class="pilcrow">¶</a>
</div>
<p id="section-5.3-16">On subsequent RTT samples, smoothed_rtt and rttvar evolve as follows:<a href="#section-5.3-16" class="pilcrow">¶</a></p>
<div class="artwork art-text alignLeft" id="section-5.3-17">
<pre>
ack_delay = decoded acknowledgement delay from ACK frame
if (handshake confirmed):
  ack_delay = min(ack_delay, max_ack_delay)
adjusted_rtt = latest_rtt
if (min_rtt + ack_delay &lt; latest_rtt):
  adjusted_rtt = latest_rtt - ack_delay
smoothed_rtt = 7/8 * smoothed_rtt + 1/8 * adjusted_rtt
rttvar_sample = abs(smoothed_rtt - adjusted_rtt)
rttvar = 3/4 * rttvar + 1/4 * rttvar_sample
</pre><a href="#section-5.3-17" class="pilcrow">¶</a>
</div>
</section>
</div>
</section>
</div>
<div id="loss-detection">
<section id="section-6">
      <h2 id="name-loss-detection">
<a href="#section-6" class="section-number selfRef">6. </a><a href="#name-loss-detection" class="section-name selfRef">Loss Detection</a>
      </h2>
<p id="section-6-1">QUIC senders use acknowledgements to detect lost packets, and a probe
time out (see <a href="#pto" class="xref">Section 6.2</a>) to ensure acknowledgements are received. This section
provides a description of these algorithms.<a href="#section-6-1" class="pilcrow">¶</a></p>
<p id="section-6-2">If a packet is lost, the QUIC transport needs to recover from that loss, such
as by retransmitting the data, sending an updated frame, or discarding the
frame.  For more information, see Section 13.3 of <span>[<a href="#QUIC-TRANSPORT" class="xref">QUIC-TRANSPORT</a>]</span>.<a href="#section-6-2" class="pilcrow">¶</a></p>
<p id="section-6-3">Loss detection is separate per packet number space, unlike RTT measurement and
congestion control, because RTT and congestion control are properties of the
path, whereas loss detection also relies upon key availability.<a href="#section-6-3" class="pilcrow">¶</a></p>
<div id="ack-loss-detection">
<section id="section-6.1">
        <h3 id="name-acknowledgement-based-detec">
<a href="#section-6.1" class="section-number selfRef">6.1. </a><a href="#name-acknowledgement-based-detec" class="section-name selfRef">Acknowledgement-Based Detection</a>
        </h3>
<p id="section-6.1-1">Acknowledgement-based loss detection implements the spirit of TCP's Fast
Retransmit (<span>[<a href="#RFC5681" class="xref">RFC5681</a>]</span>), Early Retransmit (<span>[<a href="#RFC5827" class="xref">RFC5827</a>]</span>), FACK (<span>[<a href="#FACK" class="xref">FACK</a>]</span>),
SACK loss recovery (<span>[<a href="#RFC6675" class="xref">RFC6675</a>]</span>), and RACK (<span>[<a href="#RACK" class="xref">RACK</a>]</span>). This
section provides an overview of how these algorithms are implemented in QUIC.<a href="#section-6.1-1" class="pilcrow">¶</a></p>
<p id="section-6.1-2">A packet is declared lost if it meets all the following conditions:<a href="#section-6.1-2" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="section-6.1-3.1">The packet is unacknowledged, in-flight, and was sent prior to an
acknowledged packet.<a href="#section-6.1-3.1" class="pilcrow">¶</a>
</li>
          <li class="normal" id="section-6.1-3.2">The packet was sent kPacketThreshold packets before an acknowledged packet
(<a href="#packet-threshold" class="xref">Section 6.1.1</a>), or it was sent long enough in the past
(<a href="#time-threshold" class="xref">Section 6.1.2</a>).<a href="#section-6.1-3.2" class="pilcrow">¶</a>
</li>
        </ul>
<p id="section-6.1-4">The acknowledgement indicates that a packet sent later was delivered, and the
packet and time thresholds provide some tolerance for packet reordering.<a href="#section-6.1-4" class="pilcrow">¶</a></p>
<p id="section-6.1-5">Spuriously declaring packets as lost leads to unnecessary retransmissions and
may result in degraded performance due to the actions of the congestion
controller upon detecting loss.  Implementations can detect spurious
retransmissions and increase the reordering threshold in packets or time to
reduce future spurious retransmissions and loss events. Implementations with
adaptive time thresholds MAY choose to start with smaller initial reordering
thresholds to minimize recovery latency.<a href="#section-6.1-5" class="pilcrow">¶</a></p>
<div id="packet-threshold">
<section id="section-6.1.1">
          <h4 id="name-packet-threshold">
<a href="#section-6.1.1" class="section-number selfRef">6.1.1. </a><a href="#name-packet-threshold" class="section-name selfRef">Packet Threshold</a>
          </h4>
<p id="section-6.1.1-1">The RECOMMENDED initial value for the packet reordering threshold
(kPacketThreshold) is 3, based on best practices for TCP loss detection
(<span>[<a href="#RFC5681" class="xref">RFC5681</a>]</span>, <span>[<a href="#RFC6675" class="xref">RFC6675</a>]</span>).  In order to remain similar to TCP,
implementations SHOULD NOT use a packet threshold less than 3; see <span>[<a href="#RFC5681" class="xref">RFC5681</a>]</span>.<a href="#section-6.1.1-1" class="pilcrow">¶</a></p>
<p id="section-6.1.1-2">Some networks may exhibit higher degrees of packet reordering, causing a sender
to detect spurious losses. Additionally, packet reordering could be more common
with QUIC than TCP, because network elements that could observe and reorder
TCP packets cannot do that for QUIC, because QUIC packet numbers are encrypted.
Algorithms that increase the reordering threshold after spuriously detecting
losses, such as RACK <span>[<a href="#RACK" class="xref">RACK</a>]</span>, have proven to be useful in TCP and are
expected to be at least as useful in QUIC.<a href="#section-6.1.1-2" class="pilcrow">¶</a></p>
</section>
</div>
<div id="time-threshold">
<section id="section-6.1.2">
          <h4 id="name-time-threshold">
<a href="#section-6.1.2" class="section-number selfRef">6.1.2. </a><a href="#name-time-threshold" class="section-name selfRef">Time Threshold</a>
          </h4>
<p id="section-6.1.2-1">Once a later packet within the same packet number space has been acknowledged,
an endpoint SHOULD declare an earlier packet lost if it was sent a threshold
amount of time in the past. To avoid declaring packets as lost too early, this
time threshold MUST be set to at least the local timer granularity, as
indicated by the kGranularity constant.  The time threshold is:<a href="#section-6.1.2-1" class="pilcrow">¶</a></p>
<div class="artwork art-text alignLeft" id="section-6.1.2-2">
<pre>
max(kTimeThreshold * max(smoothed_rtt, latest_rtt), kGranularity)
</pre><a href="#section-6.1.2-2" class="pilcrow">¶</a>
</div>
<p id="section-6.1.2-3">If packets sent prior to the largest acknowledged packet cannot yet be declared
lost, then a timer SHOULD be set for the remaining time.<a href="#section-6.1.2-3" class="pilcrow">¶</a></p>
<p id="section-6.1.2-4">Using max(smoothed_rtt, latest_rtt) protects from the two following cases:<a href="#section-6.1.2-4" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="section-6.1.2-5.1">the latest RTT sample is lower than the smoothed RTT, perhaps due to
reordering where the acknowledgement encountered a shorter path;<a href="#section-6.1.2-5.1" class="pilcrow">¶</a>
</li>
            <li class="normal" id="section-6.1.2-5.2">the latest RTT sample is higher than the smoothed RTT, perhaps due to a
sustained increase in the actual RTT, but the smoothed RTT has not yet caught
up.<a href="#section-6.1.2-5.2" class="pilcrow">¶</a>
</li>
          </ul>
<p id="section-6.1.2-6">The RECOMMENDED time threshold (kTimeThreshold), expressed as a round-trip time
multiplier, is 9/8. The RECOMMENDED value of the timer granularity
(kGranularity) is 1ms.<a href="#section-6.1.2-6" class="pilcrow">¶</a></p>
<span class="break"></span><dl class="dlParallel" id="section-6.1.2-7">
            <dt id="section-6.1.2-7.1">Note:</dt>
            <dd style="margin-left: 1.5em" id="section-6.1.2-7.2">
  TCP's RACK (<span>[<a href="#RACK" class="xref">RACK</a>]</span>) specifies a slightly larger
threshold, equivalent to 5/4, for a similar purpose. Experience with QUIC shows
that 9/8 works well.<a href="#section-6.1.2-7.2" class="pilcrow">¶</a>
</dd>
          <dd class="break"></dd>
</dl>
<p id="section-6.1.2-8">Implementations MAY experiment with absolute thresholds, thresholds from
previous connections, adaptive thresholds, or including RTT variation.  Smaller
thresholds reduce reordering resilience and increase spurious retransmissions,
and larger thresholds increase loss detection delay.<a href="#section-6.1.2-8" class="pilcrow">¶</a></p>
</section>
</div>
</section>
</div>
<div id="pto">
<section id="section-6.2">
        <h3 id="name-probe-timeout">
<a href="#section-6.2" class="section-number selfRef">6.2. </a><a href="#name-probe-timeout" class="section-name selfRef">Probe Timeout</a>
        </h3>
<p id="section-6.2-1">A Probe Timeout (PTO) triggers sending one or two probe datagrams when
ack-eliciting packets are not acknowledged within the expected period of
time or the server may not have validated the client's address.  A PTO enables
a connection to recover from loss of tail packets or acknowledgements.<a href="#section-6.2-1" class="pilcrow">¶</a></p>
<p id="section-6.2-2">As with loss detection, the probe timeout is per packet number space. That is, a
PTO value is computed per packet number space.<a href="#section-6.2-2" class="pilcrow">¶</a></p>
<p id="section-6.2-3">A PTO timer expiration event does not indicate packet loss and MUST NOT cause
prior unacknowledged packets to be marked as lost. When an acknowledgement
is received that newly acknowledges packets, loss detection proceeds as
dictated by packet and time threshold mechanisms; see <a href="#ack-loss-detection" class="xref">Section 6.1</a>.<a href="#section-6.2-3" class="pilcrow">¶</a></p>
<p id="section-6.2-4">The PTO algorithm used in QUIC implements the reliability functions of
Tail Loss Probe <span>[<a href="#RACK" class="xref">RACK</a>]</span>, RTO <span>[<a href="#RFC5681" class="xref">RFC5681</a>]</span>, and F-RTO algorithms for
TCP <span>[<a href="#RFC5682" class="xref">RFC5682</a>]</span>. The timeout computation is based on TCP's retransmission
timeout period <span>[<a href="#RFC6298" class="xref">RFC6298</a>]</span>.<a href="#section-6.2-4" class="pilcrow">¶</a></p>
<div id="computing-pto">
<section id="section-6.2.1">
          <h4 id="name-computing-pto">
<a href="#section-6.2.1" class="section-number selfRef">6.2.1. </a><a href="#name-computing-pto" class="section-name selfRef">Computing PTO</a>
          </h4>
<p id="section-6.2.1-1">When an ack-eliciting packet is transmitted, the sender schedules a timer for
the PTO period as follows:<a href="#section-6.2.1-1" class="pilcrow">¶</a></p>
<div class="artwork art-text alignLeft" id="section-6.2.1-2">
<pre>
PTO = smoothed_rtt + max(4*rttvar, kGranularity) + max_ack_delay
</pre><a href="#section-6.2.1-2" class="pilcrow">¶</a>
</div>
<p id="section-6.2.1-3">The PTO period is the amount of time that a sender ought to wait for an
acknowledgement of a sent packet.  This time period includes the estimated
network roundtrip-time (smoothed_rtt), the variation in the estimate (4*rttvar),
and max_ack_delay, to account for the maximum time by which a receiver might
delay sending an acknowledgement.<a href="#section-6.2.1-3" class="pilcrow">¶</a></p>
<p id="section-6.2.1-4">When the PTO is armed for Initial or Handshake packet number spaces, the
max_ack_delay in the PTO period computation is set to 0, since the peer is
expected to not delay these packets intentionally; see 13.2.1 of
<span>[<a href="#QUIC-TRANSPORT" class="xref">QUIC-TRANSPORT</a>]</span>.<a href="#section-6.2.1-4" class="pilcrow">¶</a></p>
<p id="section-6.2.1-5">The PTO period MUST be at least kGranularity, to avoid the timer expiring
immediately.<a href="#section-6.2.1-5" class="pilcrow">¶</a></p>
<p id="section-6.2.1-6">When ack-eliciting packets in multiple packet number spaces are in flight, the
timer MUST be set to the earlier value of the Initial and Handshake packet
number spaces.<a href="#section-6.2.1-6" class="pilcrow">¶</a></p>
<p id="section-6.2.1-7">An endpoint MUST NOT set its PTO timer for the application data packet number
space until the handshake is confirmed. Doing so prevents the endpoint from
retransmitting information in packets when either the peer does not yet have the
keys to process them or the endpoint does not yet have the keys to process their
acknowledgements. For example, this can happen when a client sends 0-RTT packets
to the server; it does so without knowing whether the server will be able to
decrypt them. Similarly, this can happen when a server sends 1-RTT packets
before confirming that the client has verified the server's certificate and can
therefore read these 1-RTT packets.<a href="#section-6.2.1-7" class="pilcrow">¶</a></p>
<p id="section-6.2.1-8">A sender SHOULD restart its PTO timer every time an ack-eliciting packet is sent
or acknowledged, when the handshake is confirmed (Section 4.1.2 of
<span>[<a href="#QUIC-TLS" class="xref">QUIC-TLS</a>]</span>), or when Initial or Handshake keys are discarded (Section 4.9 of
<span>[<a href="#QUIC-TLS" class="xref">QUIC-TLS</a>]</span>). This ensures the PTO is always set based on the latest estimate
of the round-trip time and for the correct packet across packet number spaces.<a href="#section-6.2.1-8" class="pilcrow">¶</a></p>
<p id="section-6.2.1-9">When a PTO timer expires, the PTO backoff MUST be increased, resulting in the
PTO period being set to twice its current value. The PTO backoff factor is reset
when an acknowledgement is received, except in the following case. A server
might take longer to respond to packets during the handshake than otherwise.  To
protect such a server from repeated client probes, the PTO backoff is not reset
at a client that is not yet certain that the server has finished validating the
client's address. That is, a client does not reset the PTO backoff factor on
receiving acknowledgements in Initial packets.<a href="#section-6.2.1-9" class="pilcrow">¶</a></p>
<p id="section-6.2.1-10">This exponential reduction in the sender's rate is important because
consecutive PTOs might be caused by loss of packets or acknowledgements due to
severe congestion.  Even when there are ack-eliciting packets in-flight in
multiple packet number spaces, the exponential increase in probe timeout
occurs across all spaces to prevent excess load on the network.  For example,
a timeout in the Initial packet number space doubles the length of the timeout
in the Handshake packet number space.<a href="#section-6.2.1-10" class="pilcrow">¶</a></p>
<p id="section-6.2.1-11">The total length of time over which consecutive PTOs expire is limited by the
idle timeout.<a href="#section-6.2.1-11" class="pilcrow">¶</a></p>
<p id="section-6.2.1-12">The PTO timer MUST NOT be set if a timer is set for time threshold
loss detection; see <a href="#time-threshold" class="xref">Section 6.1.2</a>.  A timer that is set for time
threshold loss detection will expire earlier than the PTO timer
in most cases and is less likely to spuriously retransmit data.<a href="#section-6.2.1-12" class="pilcrow">¶</a></p>
</section>
</div>
<div id="pto-handshake">
<section id="section-6.2.2">
          <h4 id="name-handshakes-and-new-paths">
<a href="#section-6.2.2" class="section-number selfRef">6.2.2. </a><a href="#name-handshakes-and-new-paths" class="section-name selfRef">Handshakes and New Paths</a>
          </h4>
<p id="section-6.2.2-1">Resumed connections over the same network MAY use the previous connection's
final smoothed RTT value as the resumed connection's initial RTT.  When no
previous RTT is available, the initial RTT SHOULD be set to 333ms.  This
results in handshakes starting with a PTO of 1 second, as recommended
for TCP's initial retransmission timeout; see Section 2 of <span>[<a href="#RFC6298" class="xref">RFC6298</a>]</span>.<a href="#section-6.2.2-1" class="pilcrow">¶</a></p>
<p id="section-6.2.2-2">A connection MAY use the delay between sending a PATH_CHALLENGE and receiving a
PATH_RESPONSE to set the initial RTT (see kInitialRtt in
<a href="#constants-of-interest" class="xref">Appendix A.2</a>) for a new path, but the delay SHOULD NOT be
considered an RTT sample.<a href="#section-6.2.2-2" class="pilcrow">¶</a></p>
<p id="section-6.2.2-3">Initial packets and Handshake packets could be never acknowledged, but they are
removed from bytes in flight when the Initial and Handshake keys are discarded,
as described below in <a href="#discarding-packets" class="xref">Section 6.4</a>. When Initial or Handshake keys are
discarded, the PTO and loss detection timers MUST be reset, because discarding
keys indicates forward progress and the loss detection timer might have been set
for a now discarded packet number space.<a href="#section-6.2.2-3" class="pilcrow">¶</a></p>
<div id="before-address-validation">
<section id="section-6.2.2.1">
            <h5 id="name-before-address-validation">
<a href="#section-6.2.2.1" class="section-number selfRef">6.2.2.1. </a><a href="#name-before-address-validation" class="section-name selfRef">Before Address Validation</a>
            </h5>
<p id="section-6.2.2.1-1">Until the server has validated the client's address on the path, the amount of
data it can send is limited to three times the amount of data received,
as specified in Section 8.1 of <span>[<a href="#QUIC-TRANSPORT" class="xref">QUIC-TRANSPORT</a>]</span>. If no additional data can be
sent, the server's PTO timer MUST NOT be armed until datagrams have been
received from the client, because packets sent on PTO count against the
anti-amplification limit. Note that the server could fail to validate the
client's address even if 0-RTT is accepted.<a href="#section-6.2.2.1-1" class="pilcrow">¶</a></p>
<p id="section-6.2.2.1-2">Since the server could be blocked until more datagrams are received from the
client, it is the client's responsibility to send packets to unblock the server
until it is certain that the server has finished its address validation
(see Section 8 of <span>[<a href="#QUIC-TRANSPORT" class="xref">QUIC-TRANSPORT</a>]</span>).  That is, the client MUST set the
probe timer if the client has not received an acknowledgement for one of its
Handshake packets and the handshake is not confirmed (see Section 4.1.2 of
<span>[<a href="#QUIC-TLS" class="xref">QUIC-TLS</a>]</span>), even if there are no packets in flight.  When the PTO fires,
the client MUST send a Handshake packet if it has Handshake keys, otherwise it
MUST send an Initial packet in a UDP datagram with a payload of at least 1200
bytes.<a href="#section-6.2.2.1-2" class="pilcrow">¶</a></p>
</section>
</div>
</section>
</div>
<div id="speeding-up-handshake-completion">
<section id="section-6.2.3">
          <h4 id="name-speeding-up-handshake-compl">
<a href="#section-6.2.3" class="section-number selfRef">6.2.3. </a><a href="#name-speeding-up-handshake-compl" class="section-name selfRef">Speeding Up Handshake Completion</a>
          </h4>
<p id="section-6.2.3-1">When a server receives an Initial packet containing duplicate CRYPTO data,
it can assume the client did not receive all of the server's CRYPTO data sent
in Initial packets, or the client's estimated RTT is too small. When a
client receives Handshake or 1-RTT packets prior to obtaining Handshake keys,
it may assume some or all of the server's Initial packets were lost.<a href="#section-6.2.3-1" class="pilcrow">¶</a></p>
<p id="section-6.2.3-2">To speed up handshake completion under these conditions, an endpoint MAY, for a
limited number of occasions per each connection, send a packet containing
unacknowledged CRYPTO data earlier than the PTO expiry, subject to the address
validation limits in Section 8.1 of <span>[<a href="#QUIC-TRANSPORT" class="xref">QUIC-TRANSPORT</a>]</span>. Doing so at most once
for each connection is adequate to quickly recover from a single packet loss.
Endpoints that do not cease retransmitting packets in response to
unauthenticated data risk creating an infinite exchange of packets.<a href="#section-6.2.3-2" class="pilcrow">¶</a></p>
<p id="section-6.2.3-3">Endpoints can also use coalesced packets (see Section 12.2 of
<span>[<a href="#QUIC-TRANSPORT" class="xref">QUIC-TRANSPORT</a>]</span>) to ensure that each datagram elicits at least one
acknowledgement. For example, a client can coalesce an Initial packet
containing PING and PADDING frames with a 0-RTT data packet and a server can
coalesce an Initial packet containing a PING frame with one or more packets in
its first flight.<a href="#section-6.2.3-3" class="pilcrow">¶</a></p>
</section>
</div>
<div id="sending-probe-packets">
<section id="section-6.2.4">
          <h4 id="name-sending-probe-packets">
<a href="#section-6.2.4" class="section-number selfRef">6.2.4. </a><a href="#name-sending-probe-packets" class="section-name selfRef">Sending Probe Packets</a>
          </h4>
<p id="section-6.2.4-1">When a PTO timer expires, a sender MUST send at least one ack-eliciting packet
in the packet number space as a probe.  An endpoint MAY send up to two
full-sized datagrams containing ack-eliciting packets, to avoid an expensive
consecutive PTO expiration due to a single lost datagram or transmit data
from multiple packet number spaces. All probe packets sent on a PTO MUST be
ack-eliciting.<a href="#section-6.2.4-1" class="pilcrow">¶</a></p>
<p id="section-6.2.4-2">In addition to sending data in the packet number space for which the timer
expired, the sender SHOULD send ack-eliciting packets from other packet
number spaces with in-flight data, coalescing packets if possible.  This is
particularly valuable when the server has both Initial and Handshake data
in-flight or the client has both Handshake and Application Data in-flight,
because the peer might only have receive keys for one of the two packet number
spaces.<a href="#section-6.2.4-2" class="pilcrow">¶</a></p>
<p id="section-6.2.4-3">If the sender wants to elicit a faster acknowledgement on PTO, it can skip a
packet number to eliminate the acknowledgment delay.<a href="#section-6.2.4-3" class="pilcrow">¶</a></p>
<p id="section-6.2.4-4">When the PTO timer expires, an ack-eliciting packet MUST be sent.  An endpoint
SHOULD include new data in this packet.  Previously sent data MAY be sent if
no new data can be sent.  Implementations MAY use alternative strategies for
determining the content of probe packets, including sending new or
retransmitted data based on the application's priorities.<a href="#section-6.2.4-4" class="pilcrow">¶</a></p>
<p id="section-6.2.4-5">It is possible the sender has no new or previously-sent data to send.
As an example, consider the following sequence of events: new application data
is sent in a STREAM frame, deemed lost, then retransmitted in a new packet,
and then the original transmission is acknowledged.  When there is no data to
send, the sender SHOULD send a PING or other ack-eliciting frame in a single
packet, re-arming the PTO timer.<a href="#section-6.2.4-5" class="pilcrow">¶</a></p>
<p id="section-6.2.4-6">Alternatively, instead of sending an ack-eliciting packet, the sender MAY mark
any packets still in flight as lost.  Doing so avoids sending an additional
packet, but increases the risk that loss is declared too aggressively, resulting
in an unnecessary rate reduction by the congestion controller.<a href="#section-6.2.4-6" class="pilcrow">¶</a></p>
<p id="section-6.2.4-7">Consecutive PTO periods increase exponentially, and as a result, connection
recovery latency increases exponentially as packets continue to be dropped in
the network.  Sending two packets on PTO expiration increases resilience to
packet drops, thus reducing the probability of consecutive PTO events.<a href="#section-6.2.4-7" class="pilcrow">¶</a></p>
<p id="section-6.2.4-8">When the PTO timer expires multiple times and new data cannot be sent,
implementations must choose between sending the same payload every time
or sending different payloads.  Sending the same payload may be simpler
and ensures the highest priority frames arrive first.  Sending different
payloads each time reduces the chances of spurious retransmission.<a href="#section-6.2.4-8" class="pilcrow">¶</a></p>
</section>
</div>
</section>
</div>
<div id="handling-retry-packets">
<section id="section-6.3">
        <h3 id="name-handling-retry-packets">
<a href="#section-6.3" class="section-number selfRef">6.3. </a><a href="#name-handling-retry-packets" class="section-name selfRef">Handling Retry Packets</a>
        </h3>
<p id="section-6.3-1">A Retry packet causes a client to send another Initial packet, effectively
restarting the connection process.  A Retry packet indicates that the Initial
was received, but not processed.  A Retry packet cannot be treated as an
acknowledgment, because it does not indicate that a packet was processed or
specify the packet number.<a href="#section-6.3-1" class="pilcrow">¶</a></p>
<p id="section-6.3-2">Clients that receive a Retry packet reset congestion control and loss recovery
state, including resetting any pending timers.  Other connection state, in
particular cryptographic handshake messages, is retained; see Section 17.2.5 of
<span>[<a href="#QUIC-TRANSPORT" class="xref">QUIC-TRANSPORT</a>]</span>.<a href="#section-6.3-2" class="pilcrow">¶</a></p>
<p id="section-6.3-3">The client MAY compute an RTT estimate to the server as the time period from
when the first Initial was sent to when a Retry or a Version Negotiation packet
is received.  The client MAY use this value in place of its default for the
initial RTT estimate.<a href="#section-6.3-3" class="pilcrow">¶</a></p>
</section>
</div>
<div id="discarding-packets">
<section id="section-6.4">
        <h3 id="name-discarding-keys-and-packet-">
<a href="#section-6.4" class="section-number selfRef">6.4. </a><a href="#name-discarding-keys-and-packet-" class="section-name selfRef">Discarding Keys and Packet State</a>
        </h3>
<p id="section-6.4-1">When packet protection keys are discarded (see Section 4.9 of <span>[<a href="#QUIC-TLS" class="xref">QUIC-TLS</a>]</span>),
all packets that were sent with those keys can no longer be acknowledged because
their acknowledgements cannot be processed anymore. The sender MUST discard
all recovery state associated with those packets and MUST remove them from
the count of bytes in flight.<a href="#section-6.4-1" class="pilcrow">¶</a></p>
<p id="section-6.4-2">Endpoints stop sending and receiving Initial packets once they start exchanging
Handshake packets; see Section 17.2.2.1 of <span>[<a href="#QUIC-TRANSPORT" class="xref">QUIC-TRANSPORT</a>]</span>. At this point,
recovery state for all in-flight Initial packets is discarded.<a href="#section-6.4-2" class="pilcrow">¶</a></p>
<p id="section-6.4-3">When 0-RTT is rejected, recovery state for all in-flight 0-RTT packets is
discarded.<a href="#section-6.4-3" class="pilcrow">¶</a></p>
<p id="section-6.4-4">If a server accepts 0-RTT, but does not buffer 0-RTT packets that arrive
before Initial packets, early 0-RTT packets will be declared lost, but that
is expected to be infrequent.<a href="#section-6.4-4" class="pilcrow">¶</a></p>
<p id="section-6.4-5">It is expected that keys are discarded after packets encrypted with them would
be acknowledged or declared lost.  However, Initial secrets are discarded as
soon as handshake keys are proven to be available to both client and server;
see Section 4.9.1 of <span>[<a href="#QUIC-TLS" class="xref">QUIC-TLS</a>]</span>.<a href="#section-6.4-5" class="pilcrow">¶</a></p>
</section>
</div>
</section>
</div>
<div id="congestion-control">
<section id="section-7">
      <h2 id="name-congestion-control">
<a href="#section-7" class="section-number selfRef">7. </a><a href="#name-congestion-control" class="section-name selfRef">Congestion Control</a>
      </h2>
<p id="section-7-1">This document specifies a sender-side congestion controller for QUIC similar to
TCP NewReno (<span>[<a href="#RFC6582" class="xref">RFC6582</a>]</span>).<a href="#section-7-1" class="pilcrow">¶</a></p>
<p id="section-7-2">The signals QUIC provides for congestion control are generic and are designed to
support different sender-side algorithms. A sender can unilaterally choose a
different algorithm to use, such as Cubic (<span>[<a href="#RFC8312" class="xref">RFC8312</a>]</span>).<a href="#section-7-2" class="pilcrow">¶</a></p>
<p id="section-7-3">If a sender uses a different controller than that specified in this document,
the chosen controller MUST conform to the congestion control guidelines
specified in Section 3.1 of <span>[<a href="#RFC8085" class="xref">RFC8085</a>]</span>.<a href="#section-7-3" class="pilcrow">¶</a></p>
<p id="section-7-4">Similar to TCP, packets containing only ACK frames do not count towards bytes
in flight and are not congestion controlled.  Unlike TCP, QUIC can detect the
loss of these packets and MAY use that information to adjust the congestion
controller or the rate of ACK-only packets being sent, but this document does
not describe a mechanism for doing so.<a href="#section-7-4" class="pilcrow">¶</a></p>
<p id="section-7-5">The algorithm in this document specifies and uses the controller's congestion
window in bytes.<a href="#section-7-5" class="pilcrow">¶</a></p>
<p id="section-7-6">An endpoint MUST NOT send a packet if it would cause bytes_in_flight (see
<a href="#vars-of-interest" class="xref">Appendix B.2</a>) to be larger than the congestion window, unless the packet
is sent on a PTO timer expiration (see <a href="#pto" class="xref">Section 6.2</a>) or when entering recovery
(see <a href="#recovery-period" class="xref">Section 7.3.2</a>).<a href="#section-7-6" class="pilcrow">¶</a></p>
<div id="congestion-ecn">
<section id="section-7.1">
        <h3 id="name-explicit-congestion-notific">
<a href="#section-7.1" class="section-number selfRef">7.1. </a><a href="#name-explicit-congestion-notific" class="section-name selfRef">Explicit Congestion Notification</a>
        </h3>
<p id="section-7.1-1">If a path has been validated to support ECN (<span>[<a href="#RFC3168" class="xref">RFC3168</a>]</span>, <span>[<a href="#RFC8311" class="xref">RFC8311</a>]</span>), QUIC
treats a Congestion Experienced (CE) codepoint in the IP header as a signal of
congestion. This document specifies an endpoint's response when the
peer-reported ECN-CE count increases; see Section 13.4.2 of <span>[<a href="#QUIC-TRANSPORT" class="xref">QUIC-TRANSPORT</a>]</span>.<a href="#section-7.1-1" class="pilcrow">¶</a></p>
</section>
</div>
<div id="initial-cwnd">
<section id="section-7.2">
        <h3 id="name-initial-and-minimum-congest">
<a href="#section-7.2" class="section-number selfRef">7.2. </a><a href="#name-initial-and-minimum-congest" class="section-name selfRef">Initial and Minimum Congestion Window</a>
        </h3>
<p id="section-7.2-1">QUIC begins every connection in slow start with the congestion window set to
an initial value.  Endpoints SHOULD use an initial congestion window of 10 times
the maximum datagram size (max_datagram_size), limited to the larger of 14720
bytes or twice the maximum datagram size. This follows the analysis and
recommendations in <span>[<a href="#RFC6928" class="xref">RFC6928</a>]</span>, increasing the byte limit to account for the
smaller 8 byte overhead of UDP compared to the 20 byte overhead for TCP.<a href="#section-7.2-1" class="pilcrow">¶</a></p>
<p id="section-7.2-2">If the maximum datagram size changes during the connection, the initial
congestion window SHOULD be recalculated with the new size.  If the maximum
datagram size is decreased in order to complete the handshake, the
congestion window SHOULD be set to the new initial congestion window.<a href="#section-7.2-2" class="pilcrow">¶</a></p>
<p id="section-7.2-3">Prior to validating the client's address, the server can be further limited by
the anti-amplification limit as specified in Section 8.1 of <span>[<a href="#QUIC-TRANSPORT" class="xref">QUIC-TRANSPORT</a>]</span>.
Though the anti-amplification limit can prevent the congestion window from
being fully utilized and therefore slow down the increase in congestion window,
it does not directly affect the congestion window.<a href="#section-7.2-3" class="pilcrow">¶</a></p>
<p id="section-7.2-4">The minimum congestion window is the smallest value the congestion window can
decrease to as a response to loss, increase in the peer-reported ECN-CE count,
or persistent congestion.  The RECOMMENDED value is 2 * max_datagram_size.<a href="#section-7.2-4" class="pilcrow">¶</a></p>
</section>
</div>
<div id="congestion-control-states">
<section id="section-7.3">
        <h3 id="name-congestion-control-states">
<a href="#section-7.3" class="section-number selfRef">7.3. </a><a href="#name-congestion-control-states" class="section-name selfRef">Congestion Control States</a>
        </h3>
<p id="section-7.3-1">The NewReno congestion controller described in this document has three
distinct states, as shown in <a href="#fig-cc-fsm" class="xref">Figure 1</a>.<a href="#section-7.3-1" class="pilcrow">¶</a></p>
<span id="name-congestion-control-states-a"></span><div id="fig-cc-fsm">
<figure id="figure-1">
          <div class="artwork art-text alignLeft" id="section-7.3-2.1">
<pre>
                 New Path or      +------------+
            persistent congestion |   Slow     |
        (O)----------------------&gt;|   Start    |
                                  +------------+
                                        |
                                Loss or |
                        ECN-CE increase |
                                        v
 +------------+     Loss or       +------------+
 | Congestion |  ECN-CE increase  |  Recovery  |
 | Avoidance  |------------------&gt;|   Period   |
 +------------+                   +------------+
           ^                            |
           |                            |
           +----------------------------+
              Acknowledgment of packet
                sent during recovery
</pre>
</div>
<figcaption><a href="#figure-1" class="selfRef">Figure 1</a>:
<a href="#name-congestion-control-states-a" class="selfRef">Congestion Control States and Transitions</a>
          </figcaption></figure>
</div>
<p id="section-7.3-3">These states and the transitions between them are described in subsequent
sections.<a href="#section-7.3-3" class="pilcrow">¶</a></p>
<div id="slow-start">
<section id="section-7.3.1">
          <h4 id="name-slow-start">
<a href="#section-7.3.1" class="section-number selfRef">7.3.1. </a><a href="#name-slow-start" class="section-name selfRef">Slow Start</a>
          </h4>
<p id="section-7.3.1-1">A NewReno sender is in slow start any time the congestion window is below the
slow start threshold. A sender begins in slow start because the slow start
threshold is initialized to an infinite value.<a href="#section-7.3.1-1" class="pilcrow">¶</a></p>
<p id="section-7.3.1-2">While a sender is in slow start, the congestion window increases by the number
of bytes acknowledged when each acknowledgment is processed. This results in
exponential growth of the congestion window.<a href="#section-7.3.1-2" class="pilcrow">¶</a></p>
<p id="section-7.3.1-3">The sender MUST exit slow start and enter a recovery period when a packet is
lost or when the ECN-CE count reported by its peer increases.<a href="#section-7.3.1-3" class="pilcrow">¶</a></p>
<p id="section-7.3.1-4">A sender re-enters slow start any time the congestion window is less than the
slow start threshold, which only occurs after persistent congestion is
declared.<a href="#section-7.3.1-4" class="pilcrow">¶</a></p>
</section>
</div>
<div id="recovery-period">
<section id="section-7.3.2">
          <h4 id="name-recovery">
<a href="#section-7.3.2" class="section-number selfRef">7.3.2. </a><a href="#name-recovery" class="section-name selfRef">Recovery</a>
          </h4>
<p id="section-7.3.2-1">A NewReno sender enters a recovery period when it detects the loss of a packet
or the ECN-CE count reported by its peer increases. A sender that is already in
a recovery period stays in it and does not re-enter it.<a href="#section-7.3.2-1" class="pilcrow">¶</a></p>
<p id="section-7.3.2-2">On entering a recovery period, a sender MUST set the slow start threshold to
half the value of the congestion window when loss is detected. The congestion
window MUST be set to the reduced value of the slow start threshold before
exiting the recovery period.<a href="#section-7.3.2-2" class="pilcrow">¶</a></p>
<p id="section-7.3.2-3">Implementations MAY reduce the congestion window immediately upon entering a
recovery period or use other mechanisms, such as Proportional Rate Reduction
(<span>[<a href="#PRR" class="xref">PRR</a>]</span>), to reduce the congestion window more gradually. If the
congestion window is reduced immediately, a single packet can be sent prior to
reduction. This speeds up loss recovery if the data in the lost packet is
retransmitted and is similar to TCP as described in Section 5 of <span>[<a href="#RFC6675" class="xref">RFC6675</a>]</span>.<a href="#section-7.3.2-3" class="pilcrow">¶</a></p>
<p id="section-7.3.2-4">The recovery period aims to limit congestion window reduction to once per round
trip. Therefore during a recovery period, the congestion window does not change
in response to new losses or increases in the ECN-CE count.<a href="#section-7.3.2-4" class="pilcrow">¶</a></p>
<p id="section-7.3.2-5">A recovery period ends and the sender enters congestion avoidance when a packet
sent during the recovery period is acknowledged. This is slightly different
from TCP's definition of recovery, which ends when the lost segment that
started recovery is acknowledged (<span>[<a href="#RFC5681" class="xref">RFC5681</a>]</span>).<a href="#section-7.3.2-5" class="pilcrow">¶</a></p>
</section>
</div>
<div id="congestion-avoidance">
<section id="section-7.3.3">
          <h4 id="name-congestion-avoidance">
<a href="#section-7.3.3" class="section-number selfRef">7.3.3. </a><a href="#name-congestion-avoidance" class="section-name selfRef">Congestion Avoidance</a>
          </h4>
<p id="section-7.3.3-1">A NewReno sender is in congestion avoidance any time the congestion window is
at or above the slow start threshold and not in a recovery period.<a href="#section-7.3.3-1" class="pilcrow">¶</a></p>
<p id="section-7.3.3-2">A sender in congestion avoidance uses an Additive Increase Multiplicative
Decrease (AIMD) approach that MUST limit the increase to the congestion window
to at most one maximum datagram size for each congestion window that is
acknowledged.<a href="#section-7.3.3-2" class="pilcrow">¶</a></p>
<p id="section-7.3.3-3">The sender exits congestion avoidance and enters a recovery period when a
packet is lost or when the ECN-CE count reported by its peer increases.<a href="#section-7.3.3-3" class="pilcrow">¶</a></p>
</section>
</div>
</section>
</div>
<div id="ignoring-loss-of-undecryptable-packets">
<section id="section-7.4">
        <h3 id="name-ignoring-loss-of-undecrypta">
<a href="#section-7.4" class="section-number selfRef">7.4. </a><a href="#name-ignoring-loss-of-undecrypta" class="section-name selfRef">Ignoring Loss of Undecryptable Packets</a>
        </h3>
<p id="section-7.4-1">During the handshake, some packet protection keys might not be available when
a packet arrives and the receiver can choose to drop the packet. In particular,
Handshake and 0-RTT packets cannot be processed until the Initial packets
arrive and 1-RTT packets cannot be processed until the handshake completes.
Endpoints MAY ignore the loss of Handshake, 0-RTT, and 1-RTT packets that might
have arrived before the peer had packet protection keys to process those
packets. Endpoints MUST NOT ignore the loss of packets that were sent after
the earliest acknowledged packet in a given packet number space.<a href="#section-7.4-1" class="pilcrow">¶</a></p>
</section>
</div>
<div id="probe-timeout">
<section id="section-7.5">
        <h3 id="name-probe-timeout-2">
<a href="#section-7.5" class="section-number selfRef">7.5. </a><a href="#name-probe-timeout-2" class="section-name selfRef">Probe Timeout</a>
        </h3>
<p id="section-7.5-1">Probe packets MUST NOT be blocked by the congestion controller.  A sender MUST
however count these packets as being additionally in flight, since these packets
add network load without establishing packet loss.  Note that sending probe
packets might cause the sender's bytes in flight to exceed the congestion window
until an acknowledgement is received that establishes loss or delivery of
packets.<a href="#section-7.5-1" class="pilcrow">¶</a></p>
</section>
</div>
<div id="persistent-congestion">
<section id="section-7.6">
        <h3 id="name-persistent-congestion">
<a href="#section-7.6" class="section-number selfRef">7.6. </a><a href="#name-persistent-congestion" class="section-name selfRef">Persistent Congestion</a>
        </h3>
<p id="section-7.6-1">When a sender establishes loss of all in-flight packets sent over a long enough
duration, the network is considered to be experiencing persistent congestion.<a href="#section-7.6-1" class="pilcrow">¶</a></p>
<div id="pc-duration">
<section id="section-7.6.1">
          <h4 id="name-duration">
<a href="#section-7.6.1" class="section-number selfRef">7.6.1. </a><a href="#name-duration" class="section-name selfRef">Duration</a>
          </h4>
<p id="section-7.6.1-1">The persistent congestion duration is computed as follows:<a href="#section-7.6.1-1" class="pilcrow">¶</a></p>
<div class="artwork art-text alignLeft" id="section-7.6.1-2">
<pre>
(smoothed_rtt + max(4*rttvar, kGranularity) + max_ack_delay) *
    kPersistentCongestionThreshold
</pre><a href="#section-7.6.1-2" class="pilcrow">¶</a>
</div>
<p id="section-7.6.1-3">Unlike the PTO computation in <a href="#pto" class="xref">Section 6.2</a>, this duration includes the max_ack_delay
irrespective of the packet number spaces in which losses are established.<a href="#section-7.6.1-3" class="pilcrow">¶</a></p>
<p id="section-7.6.1-4">This duration allows a sender to send as many packets before establishing
persistent congestion, including some in response to PTO expiration, as TCP does
with Tail Loss Probes (<span>[<a href="#RACK" class="xref">RACK</a>]</span>) and a Retransmission Timeout (<span>[<a href="#RFC5681" class="xref">RFC5681</a>]</span>).<a href="#section-7.6.1-4" class="pilcrow">¶</a></p>
<p id="section-7.6.1-5">Larger values of kPersistentCongestionThreshold cause the sender to become less
responsive to persistent congestion in the network, which can result in
aggressive sending into a congested network. Too small a value can result in a
sender declaring persistent congestion unnecessarily, resulting in reduced
throughput for the sender.<a href="#section-7.6.1-5" class="pilcrow">¶</a></p>
<p id="section-7.6.1-6">The RECOMMENDED value for kPersistentCongestionThreshold is 3, which results in
behavior that is approximately equivalent to a TCP sender declaring an RTO after
two TLPs.<a href="#section-7.6.1-6" class="pilcrow">¶</a></p>
<p id="section-7.6.1-7">This design does not use consecutive PTO events to establish persistent
congestion, since application patterns impact PTO expirations. For example, a
sender that sends small amounts of data with silence periods between them
restarts the PTO timer every time it sends, potentially preventing the PTO timer
from expiring for a long period of time, even when no acknowledgments are being
received. The use of a duration enables a sender to establish persistent
congestion without depending on PTO expiration.<a href="#section-7.6.1-7" class="pilcrow">¶</a></p>
</section>
</div>
<div id="establishing-persistent-congestion">
<section id="section-7.6.2">
          <h4 id="name-establishing-persistent-con">
<a href="#section-7.6.2" class="section-number selfRef">7.6.2. </a><a href="#name-establishing-persistent-con" class="section-name selfRef">Establishing Persistent Congestion</a>
          </h4>
<p id="section-7.6.2-1">A sender establishes persistent congestion on receiving an acknowledgement if at
least two ack-eliciting packets are declared lost, and:<a href="#section-7.6.2-1" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="section-7.6.2-2.1">all packets, across all packet number spaces, sent between these two send
times are declared lost;<a href="#section-7.6.2-2.1" class="pilcrow">¶</a>
</li>
            <li class="normal" id="section-7.6.2-2.2">the duration between the send times of these two packets exceeds the
persistent congestion duration (<a href="#pc-duration" class="xref">Section 7.6.1</a>); and<a href="#section-7.6.2-2.2" class="pilcrow">¶</a>
</li>
            <li class="normal" id="section-7.6.2-2.3">a prior RTT sample existed when both packets were sent.<a href="#section-7.6.2-2.3" class="pilcrow">¶</a>
</li>
          </ul>
<p id="section-7.6.2-3">The persistent congestion period SHOULD NOT start until there is at least one
RTT sample. Before the first RTT sample, a sender arms its PTO timer based on
the initial RTT (<a href="#pto-handshake" class="xref">Section 6.2.2</a>), which could be substantially larger than
the actual RTT. Requiring a prior RTT sample prevents a sender from establishing
persistent congestion with potentially too few probes.<a href="#section-7.6.2-3" class="pilcrow">¶</a></p>
<p id="section-7.6.2-4">Since network congestion is not affected by packet number spaces, persistent
congestion SHOULD consider packets sent across packet number spaces. A sender
that does not have state for all packet number spaces or an implementation that
cannot compare send times across packet number spaces MAY use state for just the
packet number space that was acknowledged.<a href="#section-7.6.2-4" class="pilcrow">¶</a></p>
<p id="section-7.6.2-5">When persistent congestion is declared, the sender's congestion window MUST be
reduced to the minimum congestion window (kMinimumWindow), similar to a TCP
sender's response on an RTO (<span>[<a href="#RFC5681" class="xref">RFC5681</a>]</span>).<a href="#section-7.6.2-5" class="pilcrow">¶</a></p>
</section>
</div>
<div id="example">
<section id="section-7.6.3">
          <h4 id="name-example">
<a href="#section-7.6.3" class="section-number selfRef">7.6.3. </a><a href="#name-example" class="section-name selfRef">Example</a>
          </h4>
<p id="section-7.6.3-1">The following example illustrates how a sender might establish persistent
congestion. Assume:<a href="#section-7.6.3-1" class="pilcrow">¶</a></p>
<div class="artwork art-text alignLeft" id="section-7.6.3-2">
<pre>
smoothed_rtt + max(4*rttvar, kGranularity) + max_ack_delay = 2
kPersistentCongestionThreshold = 3
</pre><a href="#section-7.6.3-2" class="pilcrow">¶</a>
</div>
<p id="section-7.6.3-3">Consider the following sequence of events:<a href="#section-7.6.3-3" class="pilcrow">¶</a></p>
<table class="center" id="table-1">
            <caption><a href="#table-1" class="selfRef">Table 1</a></caption>
<thead>
              <tr>
                <th class="text-left" rowspan="1" colspan="1">Time</th>
                <th class="text-left" rowspan="1" colspan="1">Action</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td class="text-left" rowspan="1" colspan="1">t=0</td>
                <td class="text-left" rowspan="1" colspan="1">Send packet #1 (app data)</td>
              </tr>
              <tr>
                <td class="text-left" rowspan="1" colspan="1">t=1</td>
                <td class="text-left" rowspan="1" colspan="1">Send packet #2 (app data)</td>
              </tr>
              <tr>
                <td class="text-left" rowspan="1" colspan="1">t=1.2</td>
                <td class="text-left" rowspan="1" colspan="1">Recv acknowledgement of #1</td>
              </tr>
              <tr>
                <td class="text-left" rowspan="1" colspan="1">t=2</td>
                <td class="text-left" rowspan="1" colspan="1">Send packet #3 (app data)</td>
              </tr>
              <tr>
                <td class="text-left" rowspan="1" colspan="1">t=3</td>
                <td class="text-left" rowspan="1" colspan="1">Send packet #4 (app data)</td>
              </tr>
              <tr>
                <td class="text-left" rowspan="1" colspan="1">t=4</td>
                <td class="text-left" rowspan="1" colspan="1">Send packet #5 (app data)</td>
              </tr>
              <tr>
                <td class="text-left" rowspan="1" colspan="1">t=5</td>
                <td class="text-left" rowspan="1" colspan="1">Send packet #6 (app data)</td>
              </tr>
              <tr>
                <td class="text-left" rowspan="1" colspan="1">t=6</td>
                <td class="text-left" rowspan="1" colspan="1">Send packet #7 (app data)</td>
              </tr>
              <tr>
                <td class="text-left" rowspan="1" colspan="1">t=8</td>
                <td class="text-left" rowspan="1" colspan="1">Send packet #8 (PTO 1)</td>
              </tr>
              <tr>
                <td class="text-left" rowspan="1" colspan="1">t=12</td>
                <td class="text-left" rowspan="1" colspan="1">Send packet #9 (PTO 2)</td>
              </tr>
              <tr>
                <td class="text-left" rowspan="1" colspan="1">t=12.2</td>
                <td class="text-left" rowspan="1" colspan="1">Recv acknowledgement of #9</td>
              </tr>
            </tbody>
          </table>
<p id="section-7.6.3-5">Packets 2 through 8 are declared lost when the acknowledgement for packet 9 is
received at t = 12.2.<a href="#section-7.6.3-5" class="pilcrow">¶</a></p>
<p id="section-7.6.3-6">The congestion period is calculated as the time between the oldest and newest
lost packets: 8 - 1 = 7.  The persistent congestion duration is: 2 * 3 = 6.
Because the threshold was reached and because none of the packets between the
oldest and the newest lost packets were acknowledged, the network is considered
to have experienced persistent congestion.<a href="#section-7.6.3-6" class="pilcrow">¶</a></p>
<p id="section-7.6.3-7">While this example shows PTO expiration, they are not required for persistent
congestion to be established.<a href="#section-7.6.3-7" class="pilcrow">¶</a></p>
</section>
</div>
</section>
</div>
<div id="pacing">
<section id="section-7.7">
        <h3 id="name-pacing">
<a href="#section-7.7" class="section-number selfRef">7.7. </a><a href="#name-pacing" class="section-name selfRef">Pacing</a>
        </h3>
<p id="section-7.7-1">A sender SHOULD pace sending of all in-flight packets based on input from the
congestion controller.<a href="#section-7.7-1" class="pilcrow">¶</a></p>
<p id="section-7.7-2">Sending multiple packets into the network without any delay between them creates
a packet burst that might cause short-term congestion and losses. Senders MUST
either use pacing or limit such bursts. Senders SHOULD limit bursts to the
initial congestion window; see <a href="#initial-cwnd" class="xref">Section 7.2</a>. A sender with knowledge that
the network path to the receiver can absorb larger bursts MAY use a higher
limit.<a href="#section-7.7-2" class="pilcrow">¶</a></p>
<p id="section-7.7-3">An implementation should take care to architect its congestion controller to
work well with a pacer.  For instance, a pacer might wrap the congestion
controller and control the availability of the congestion window, or a pacer
might pace out packets handed to it by the congestion controller.<a href="#section-7.7-3" class="pilcrow">¶</a></p>
<p id="section-7.7-4">Timely delivery of ACK frames is important for efficient loss recovery. Packets
containing only ACK frames SHOULD therefore not be paced, to avoid delaying
their delivery to the peer.<a href="#section-7.7-4" class="pilcrow">¶</a></p>
<p id="section-7.7-5">Endpoints can implement pacing as they choose. A perfectly paced sender spreads
packets exactly evenly over time. For a window-based congestion controller, such
as the one in this document, that rate can be computed by averaging the
congestion window over the round-trip time. Expressed as a rate in bytes:<a href="#section-7.7-5" class="pilcrow">¶</a></p>
<div class="artwork art-text alignLeft" id="section-7.7-6">
<pre>
rate = N * congestion_window / smoothed_rtt
</pre><a href="#section-7.7-6" class="pilcrow">¶</a>
</div>
<p id="section-7.7-7">Or, expressed as an inter-packet interval:<a href="#section-7.7-7" class="pilcrow">¶</a></p>
<div class="artwork art-text alignLeft" id="section-7.7-8">
<pre>
interval = smoothed_rtt * packet_size / congestion_window / N
</pre><a href="#section-7.7-8" class="pilcrow">¶</a>
</div>
<p id="section-7.7-9">Using a value for <code>N</code> that is small, but at least 1 (for example, 1.25) ensures
that variations in round-trip time do not result in under-utilization of the
congestion window.<a href="#section-7.7-9" class="pilcrow">¶</a></p>
<p id="section-7.7-10">Practical considerations, such as packetization, scheduling delays, and
computational efficiency, can cause a sender to deviate from this rate over time
periods that are much shorter than a round-trip time.<a href="#section-7.7-10" class="pilcrow">¶</a></p>
<p id="section-7.7-11">One possible implementation strategy for pacing uses a leaky bucket algorithm,
where the capacity of the "bucket" is limited to the maximum burst size and the
rate the "bucket" fills is determined by the above function.<a href="#section-7.7-11" class="pilcrow">¶</a></p>
</section>
</div>
<div id="under-utilizing-the-congestion-window">
<section id="section-7.8">
        <h3 id="name-under-utilizing-the-congest">
<a href="#section-7.8" class="section-number selfRef">7.8. </a><a href="#name-under-utilizing-the-congest" class="section-name selfRef">Under-utilizing the Congestion Window</a>
        </h3>
<p id="section-7.8-1">When bytes in flight is smaller than the congestion window and sending is not
pacing limited, the congestion window is under-utilized.  When this occurs,
the congestion window SHOULD NOT be increased in either slow start or
congestion avoidance. This can happen due to insufficient application data
or flow control limits.<a href="#section-7.8-1" class="pilcrow">¶</a></p>
<p id="section-7.8-2">A sender that paces packets (see <a href="#pacing" class="xref">Section 7.7</a>) might delay sending packets
and not fully utilize the congestion window due to this delay. A sender
SHOULD NOT consider itself application limited if it would have fully
utilized the congestion window without pacing delay.<a href="#section-7.8-2" class="pilcrow">¶</a></p>
<p id="section-7.8-3">A sender MAY implement alternative mechanisms to update its congestion window
after periods of under-utilization, such as those proposed for TCP in
<span>[<a href="#RFC7661" class="xref">RFC7661</a>]</span>.<a href="#section-7.8-3" class="pilcrow">¶</a></p>
</section>
</div>
</section>
</div>
<div id="security-considerations">
<section id="section-8">
      <h2 id="name-security-considerations">
<a href="#section-8" class="section-number selfRef">8. </a><a href="#name-security-considerations" class="section-name selfRef">Security Considerations</a>
      </h2>
<div id="congestion-signals">
<section id="section-8.1">
        <h3 id="name-congestion-signals">
<a href="#section-8.1" class="section-number selfRef">8.1. </a><a href="#name-congestion-signals" class="section-name selfRef">Congestion Signals</a>
        </h3>
<p id="section-8.1-1">Congestion control fundamentally involves the consumption of signals - both
loss and ECN codepoints - from unauthenticated entities.  On-path attackers can
spoof or alter these signals.  An attacker can cause endpoints to reduce their
sending rate by dropping packets, or alter send rate by changing ECN codepoints.<a href="#section-8.1-1" class="pilcrow">¶</a></p>
</section>
</div>
<div id="traffic-analysis">
<section id="section-8.2">
        <h3 id="name-traffic-analysis">
<a href="#section-8.2" class="section-number selfRef">8.2. </a><a href="#name-traffic-analysis" class="section-name selfRef">Traffic Analysis</a>
        </h3>
<p id="section-8.2-1">Packets that carry only ACK frames can be heuristically identified by observing
packet size.  Acknowledgement patterns may expose information about link
characteristics or application behavior.  To reduce leaked information,
endpoints can bundle acknowledgments with other frames, or they can use PADDING
frames at a potential cost to performance.<a href="#section-8.2-1" class="pilcrow">¶</a></p>
</section>
</div>
<div id="misreporting-ecn-markings">
<section id="section-8.3">
        <h3 id="name-misreporting-ecn-markings">
<a href="#section-8.3" class="section-number selfRef">8.3. </a><a href="#name-misreporting-ecn-markings" class="section-name selfRef">Misreporting ECN Markings</a>
        </h3>
<p id="section-8.3-1">A receiver can misreport ECN markings to alter the congestion response of a
sender.  Suppressing reports of ECN-CE markings could cause a sender to
increase their send rate.  This increase could result in congestion and loss.<a href="#section-8.3-1" class="pilcrow">¶</a></p>
<p id="section-8.3-2">A sender can detect suppression of reports by marking occasional packets that it
sends with an ECN-CE marking. If a packet sent with an ECN-CE marking is not
reported as having been CE marked when the packet is acknowledged, then the
sender can disable ECN for that path by not setting ECT codepoints in subsequent
packets sent on that path <span>[<a href="#RFC3168" class="xref">RFC3168</a>]</span>.<a href="#section-8.3-2" class="pilcrow">¶</a></p>
<p id="section-8.3-3">Reporting additional ECN-CE markings will cause a sender to reduce their sending
rate, which is similar in effect to advertising reduced connection flow control
limits and so no advantage is gained by doing so.<a href="#section-8.3-3" class="pilcrow">¶</a></p>
<p id="section-8.3-4">Endpoints choose the congestion controller that they use. Congestion controllers
respond to reports of ECN-CE by reducing their rate, but the response may vary.
Markings can be treated as equivalent to loss (<span>[<a href="#RFC3168" class="xref">RFC3168</a>]</span>), but other
responses can be specified, such as (<span>[<a href="#RFC8511" class="xref">RFC8511</a>]</span>) or (<span>[<a href="#RFC8311" class="xref">RFC8311</a>]</span>).<a href="#section-8.3-4" class="pilcrow">¶</a></p>
</section>
</div>
</section>
</div>
<div id="iana-considerations">
<section id="section-9">
      <h2 id="name-iana-considerations">
<a href="#section-9" class="section-number selfRef">9. </a><a href="#name-iana-considerations" class="section-name selfRef">IANA Considerations</a>
      </h2>
<p id="section-9-1">This document has no IANA actions.<a href="#section-9-1" class="pilcrow">¶</a></p>
</section>
</div>
<section id="section-10">
      <h2 id="name-references">
<a href="#section-10" class="section-number selfRef">10. </a><a href="#name-references" class="section-name selfRef">References</a>
      </h2>
<section id="section-10.1">
        <h3 id="name-normative-references">
<a href="#section-10.1" class="section-number selfRef">10.1. </a><a href="#name-normative-references" class="section-name selfRef">Normative References</a>
        </h3>
<dl class="references">
<dt id="QUIC-TLS">[QUIC-TLS]</dt>
        <dd>
<span class="refAuthor">Thomson, M., Ed.</span><span class="refAuthor"> and S. Turner, Ed.</span>, <span class="refTitle">"Using TLS to Secure QUIC"</span>, <span class="refContent">Work in Progress</span>, <span class="seriesInfo">Internet-Draft, draft-ietf-quic-tls</span>, <time datetime="2020-11-18" class="refDate">18 November 2020</time>, <span>&lt;<a href="https://tools.ietf.org/html/draft-ietf-quic-tls">https://tools.ietf.org/html/draft-ietf-quic-tls</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="QUIC-TRANSPORT">[QUIC-TRANSPORT]</dt>
        <dd>
<span class="refAuthor">Iyengar, J., Ed.</span><span class="refAuthor"> and M. Thomson, Ed.</span>, <span class="refTitle">"QUIC: A UDP-Based Multiplexed and Secure Transport"</span>, <span class="refContent">Work in Progress</span>, <span class="seriesInfo">Internet-Draft, draft-ietf-quic-transport</span>, <time datetime="2020-11-18" class="refDate">18 November 2020</time>, <span>&lt;<a href="https://tools.ietf.org/html/draft-ietf-quic-transport">https://tools.ietf.org/html/draft-ietf-quic-transport</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="RFC2119">[RFC2119]</dt>
        <dd>
<span class="refAuthor">Bradner, S.</span>, <span class="refTitle">"Key words for use in RFCs to Indicate Requirement Levels"</span>, <span class="seriesInfo">BCP 14</span>, <span class="seriesInfo">RFC 2119</span>, <span class="seriesInfo">DOI 10.17487/RFC2119</span>, <time datetime="1997-03" class="refDate">March 1997</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc2119">https://www.rfc-editor.org/info/rfc2119</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="RFC3168">[RFC3168]</dt>
        <dd>
<span class="refAuthor">Ramakrishnan, K.</span><span class="refAuthor">, Floyd, S.</span><span class="refAuthor">, and D. Black</span>, <span class="refTitle">"The Addition of Explicit Congestion Notification (ECN) to IP"</span>, <span class="seriesInfo">RFC 3168</span>, <span class="seriesInfo">DOI 10.17487/RFC3168</span>, <time datetime="2001-09" class="refDate">September 2001</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc3168">https://www.rfc-editor.org/info/rfc3168</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="RFC8085">[RFC8085]</dt>
        <dd>
<span class="refAuthor">Eggert, L.</span><span class="refAuthor">, Fairhurst, G.</span><span class="refAuthor">, and G. Shepherd</span>, <span class="refTitle">"UDP Usage Guidelines"</span>, <span class="seriesInfo">BCP 145</span>, <span class="seriesInfo">RFC 8085</span>, <span class="seriesInfo">DOI 10.17487/RFC8085</span>, <time datetime="2017-03" class="refDate">March 2017</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc8085">https://www.rfc-editor.org/info/rfc8085</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="RFC8174">[RFC8174]</dt>
      <dd>
<span class="refAuthor">Leiba, B.</span>, <span class="refTitle">"Ambiguity of Uppercase vs Lowercase in RFC 2119 Key Words"</span>, <span class="seriesInfo">BCP 14</span>, <span class="seriesInfo">RFC 8174</span>, <span class="seriesInfo">DOI 10.17487/RFC8174</span>, <time datetime="2017-05" class="refDate">May 2017</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc8174">https://www.rfc-editor.org/info/rfc8174</a>&gt;</span>. </dd>
<dd class="break"></dd>
</dl>
</section>
<section id="section-10.2">
        <h3 id="name-informative-references">
<a href="#section-10.2" class="section-number selfRef">10.2. </a><a href="#name-informative-references" class="section-name selfRef">Informative References</a>
        </h3>
<dl class="references">
<dt id="FACK">[FACK]</dt>
        <dd>
<span class="refAuthor">Mathis, M.</span><span class="refAuthor"> and J. Mahdavi</span>, <span class="refTitle">"Forward Acknowledgement: Refining TCP Congestion Control"</span>, <span class="seriesInfo">ACM SIGCOMM </span>, <time datetime="1996-08" class="refDate">August 1996</time>. </dd>
<dd class="break"></dd>
<dt id="PRR">[PRR]</dt>
        <dd>
<span class="refAuthor">Mathis, M.</span><span class="refAuthor">, Dukkipati, N.</span><span class="refAuthor">, and Y. Cheng</span>, <span class="refTitle">"Proportional Rate Reduction for TCP"</span>, <span class="seriesInfo">RFC 6937</span>, <span class="seriesInfo">DOI 10.17487/RFC6937</span>, <time datetime="2013-05" class="refDate">May 2013</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc6937">https://www.rfc-editor.org/info/rfc6937</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="RACK">[RACK]</dt>
        <dd>
<span class="refAuthor">Cheng, Y.</span><span class="refAuthor">, Cardwell, N.</span><span class="refAuthor">, Dukkipati, N.</span><span class="refAuthor">, and P. Jha</span>, <span class="refTitle">"The RACK-TLP loss detection algorithm for TCP"</span>, <span class="refContent">Work in Progress</span>, <span class="seriesInfo">Internet-Draft, draft-ietf-tcpm-rack-13</span>, <time datetime="2020-11-02" class="refDate">2 November 2020</time>, <span>&lt;<a href="http://www.ietf.org/internet-drafts/draft-ietf-tcpm-rack-13.txt">http://www.ietf.org/internet-drafts/draft-ietf-tcpm-rack-13.txt</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="RFC3465">[RFC3465]</dt>
        <dd>
<span class="refAuthor">Allman, M.</span>, <span class="refTitle">"TCP Congestion Control with Appropriate Byte Counting (ABC)"</span>, <span class="seriesInfo">RFC 3465</span>, <span class="seriesInfo">DOI 10.17487/RFC3465</span>, <time datetime="2003-02" class="refDate">February 2003</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc3465">https://www.rfc-editor.org/info/rfc3465</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="RFC5681">[RFC5681]</dt>
        <dd>
<span class="refAuthor">Allman, M.</span><span class="refAuthor">, Paxson, V.</span><span class="refAuthor">, and E. Blanton</span>, <span class="refTitle">"TCP Congestion Control"</span>, <span class="seriesInfo">RFC 5681</span>, <span class="seriesInfo">DOI 10.17487/RFC5681</span>, <time datetime="2009-09" class="refDate">September 2009</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc5681">https://www.rfc-editor.org/info/rfc5681</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="RFC5682">[RFC5682]</dt>
        <dd>
<span class="refAuthor">Sarolahti, P.</span><span class="refAuthor">, Kojo, M.</span><span class="refAuthor">, Yamamoto, K.</span><span class="refAuthor">, and M. Hata</span>, <span class="refTitle">"Forward RTO-Recovery (F-RTO): An Algorithm for Detecting Spurious Retransmission Timeouts with TCP"</span>, <span class="seriesInfo">RFC 5682</span>, <span class="seriesInfo">DOI 10.17487/RFC5682</span>, <time datetime="2009-09" class="refDate">September 2009</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc5682">https://www.rfc-editor.org/info/rfc5682</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="RFC5827">[RFC5827]</dt>
        <dd>
<span class="refAuthor">Allman, M.</span><span class="refAuthor">, Avrachenkov, K.</span><span class="refAuthor">, Ayesta, U.</span><span class="refAuthor">, Blanton, J.</span><span class="refAuthor">, and P. Hurtig</span>, <span class="refTitle">"Early Retransmit for TCP and Stream Control Transmission Protocol (SCTP)"</span>, <span class="seriesInfo">RFC 5827</span>, <span class="seriesInfo">DOI 10.17487/RFC5827</span>, <time datetime="2010-05" class="refDate">May 2010</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc5827">https://www.rfc-editor.org/info/rfc5827</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="RFC6298">[RFC6298]</dt>
        <dd>
<span class="refAuthor">Paxson, V.</span><span class="refAuthor">, Allman, M.</span><span class="refAuthor">, Chu, J.</span><span class="refAuthor">, and M. Sargent</span>, <span class="refTitle">"Computing TCP's Retransmission Timer"</span>, <span class="seriesInfo">RFC 6298</span>, <span class="seriesInfo">DOI 10.17487/RFC6298</span>, <time datetime="2011-06" class="refDate">June 2011</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc6298">https://www.rfc-editor.org/info/rfc6298</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="RFC6582">[RFC6582]</dt>
        <dd>
<span class="refAuthor">Henderson, T.</span><span class="refAuthor">, Floyd, S.</span><span class="refAuthor">, Gurtov, A.</span><span class="refAuthor">, and Y. Nishida</span>, <span class="refTitle">"The NewReno Modification to TCP's Fast Recovery Algorithm"</span>, <span class="seriesInfo">RFC 6582</span>, <span class="seriesInfo">DOI 10.17487/RFC6582</span>, <time datetime="2012-04" class="refDate">April 2012</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc6582">https://www.rfc-editor.org/info/rfc6582</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="RFC6675">[RFC6675]</dt>
        <dd>
<span class="refAuthor">Blanton, E.</span><span class="refAuthor">, Allman, M.</span><span class="refAuthor">, Wang, L.</span><span class="refAuthor">, Jarvinen, I.</span><span class="refAuthor">, Kojo, M.</span><span class="refAuthor">, and Y. Nishida</span>, <span class="refTitle">"A Conservative Loss Recovery Algorithm Based on Selective Acknowledgment (SACK) for TCP"</span>, <span class="seriesInfo">RFC 6675</span>, <span class="seriesInfo">DOI 10.17487/RFC6675</span>, <time datetime="2012-08" class="refDate">August 2012</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc6675">https://www.rfc-editor.org/info/rfc6675</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="RFC6928">[RFC6928]</dt>
        <dd>
<span class="refAuthor">Chu, J.</span><span class="refAuthor">, Dukkipati, N.</span><span class="refAuthor">, Cheng, Y.</span><span class="refAuthor">, and M. Mathis</span>, <span class="refTitle">"Increasing TCP's Initial Window"</span>, <span class="seriesInfo">RFC 6928</span>, <span class="seriesInfo">DOI 10.17487/RFC6928</span>, <time datetime="2013-04" class="refDate">April 2013</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc6928">https://www.rfc-editor.org/info/rfc6928</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="RFC7661">[RFC7661]</dt>
        <dd>
<span class="refAuthor">Fairhurst, G.</span><span class="refAuthor">, Sathiaseelan, A.</span><span class="refAuthor">, and R. Secchi</span>, <span class="refTitle">"Updating TCP to Support Rate-Limited Traffic"</span>, <span class="seriesInfo">RFC 7661</span>, <span class="seriesInfo">DOI 10.17487/RFC7661</span>, <time datetime="2015-10" class="refDate">October 2015</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc7661">https://www.rfc-editor.org/info/rfc7661</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="RFC8311">[RFC8311]</dt>
        <dd>
<span class="refAuthor">Black, D.</span>, <span class="refTitle">"Relaxing Restrictions on Explicit Congestion Notification (ECN) Experimentation"</span>, <span class="seriesInfo">RFC 8311</span>, <span class="seriesInfo">DOI 10.17487/RFC8311</span>, <time datetime="2018-01" class="refDate">January 2018</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc8311">https://www.rfc-editor.org/info/rfc8311</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="RFC8312">[RFC8312]</dt>
        <dd>
<span class="refAuthor">Rhee, I.</span><span class="refAuthor">, Xu, L.</span><span class="refAuthor">, Ha, S.</span><span class="refAuthor">, Zimmermann, A.</span><span class="refAuthor">, Eggert, L.</span><span class="refAuthor">, and R. Scheffenegger</span>, <span class="refTitle">"CUBIC for Fast Long-Distance Networks"</span>, <span class="seriesInfo">RFC 8312</span>, <span class="seriesInfo">DOI 10.17487/RFC8312</span>, <time datetime="2018-02" class="refDate">February 2018</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc8312">https://www.rfc-editor.org/info/rfc8312</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="RFC8511">[RFC8511]</dt>
      <dd>
<span class="refAuthor">Khademi, N.</span><span class="refAuthor">, Welzl, M.</span><span class="refAuthor">, Armitage, G.</span><span class="refAuthor">, and G. Fairhurst</span>, <span class="refTitle">"TCP Alternative Backoff with ECN (ABE)"</span>, <span class="seriesInfo">RFC 8511</span>, <span class="seriesInfo">DOI 10.17487/RFC8511</span>, <time datetime="2018-12" class="refDate">December 2018</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc8511">https://www.rfc-editor.org/info/rfc8511</a>&gt;</span>. </dd>
<dd class="break"></dd>
</dl>
</section>
</section>
<div id="loss-recovery-pseudocode">
<section id="section-appendix.a">
      <h2 id="name-loss-recovery-pseudocode">
<a href="#section-appendix.a" class="section-number selfRef">Appendix A. </a><a href="#name-loss-recovery-pseudocode" class="section-name selfRef">Loss Recovery Pseudocode</a>
      </h2>
<p id="section-appendix.a-1">We now describe an example implementation of the loss detection mechanisms
described in <a href="#loss-detection" class="xref">Section 6</a>.<a href="#section-appendix.a-1" class="pilcrow">¶</a></p>
<p id="section-appendix.a-2">The pseudocode segments in this section are licensed as Code Components; see the
copyright notice.<a href="#section-appendix.a-2" class="pilcrow">¶</a></p>
<div id="tracking-sent-packets">
<section id="section-a.1">
        <h2 id="name-tracking-sent-packets">
<a href="#section-a.1" class="section-number selfRef">A.1. </a><a href="#name-tracking-sent-packets" class="section-name selfRef">Tracking Sent Packets</a>
        </h2>
<p id="section-a.1-1">To correctly implement congestion control, a QUIC sender tracks every
ack-eliciting packet until the packet is acknowledged or lost.
It is expected that implementations will be able to access this information by
packet number and crypto context and store the per-packet fields
(<a href="#sent-packets-fields" class="xref">Appendix A.1.1</a>) for loss recovery and congestion control.<a href="#section-a.1-1" class="pilcrow">¶</a></p>
<p id="section-a.1-2">After a packet is declared lost, the endpoint can still maintain state for it
for an amount of time to allow for packet reordering; see Section 13.3 of
<span>[<a href="#QUIC-TRANSPORT" class="xref">QUIC-TRANSPORT</a>]</span>. This enables a sender to detect spurious retransmissions.<a href="#section-a.1-2" class="pilcrow">¶</a></p>
<p id="section-a.1-3">Sent packets are tracked for each packet number space, and ACK
processing only applies to a single space.<a href="#section-a.1-3" class="pilcrow">¶</a></p>
<div id="sent-packets-fields">
<section id="section-a.1.1">
          <h3 id="name-sent-packet-fields">
<a href="#section-a.1.1" class="section-number selfRef">A.1.1. </a><a href="#name-sent-packet-fields" class="section-name selfRef">Sent Packet Fields</a>
          </h3>
<span class="break"></span><dl class="dlParallel" id="section-a.1.1-1">
            <dt id="section-a.1.1-1.1">packet_number:</dt>
            <dd style="margin-left: 1.5em" id="section-a.1.1-1.2">
  The packet number of the sent packet.<a href="#section-a.1.1-1.2" class="pilcrow">¶</a>
</dd>
            <dd class="break"></dd>
<dt id="section-a.1.1-1.3">ack_eliciting:</dt>
            <dd style="margin-left: 1.5em" id="section-a.1.1-1.4">
  A boolean that indicates whether a packet is ack-eliciting.
If true, it is expected that an acknowledgement will be received,
though the peer could delay sending the ACK frame containing it
by up to the max_ack_delay.<a href="#section-a.1.1-1.4" class="pilcrow">¶</a>
</dd>
            <dd class="break"></dd>
<dt id="section-a.1.1-1.5">in_flight:</dt>
            <dd style="margin-left: 1.5em" id="section-a.1.1-1.6">
  A boolean that indicates whether the packet counts towards bytes in
flight.<a href="#section-a.1.1-1.6" class="pilcrow">¶</a>
</dd>
            <dd class="break"></dd>
<dt id="section-a.1.1-1.7">sent_bytes:</dt>
            <dd style="margin-left: 1.5em" id="section-a.1.1-1.8">
  The number of bytes sent in the packet, not including UDP or IP
overhead, but including QUIC framing overhead.<a href="#section-a.1.1-1.8" class="pilcrow">¶</a>
</dd>
            <dd class="break"></dd>
<dt id="section-a.1.1-1.9">time_sent:</dt>
            <dd style="margin-left: 1.5em" id="section-a.1.1-1.10">
  The time the packet was sent.<a href="#section-a.1.1-1.10" class="pilcrow">¶</a>
</dd>
          <dd class="break"></dd>
</dl>
</section>
</div>
</section>
</div>
<div id="constants-of-interest">
<section id="section-a.2">
        <h2 id="name-constants-of-interest">
<a href="#section-a.2" class="section-number selfRef">A.2. </a><a href="#name-constants-of-interest" class="section-name selfRef">Constants of Interest</a>
        </h2>
<p id="section-a.2-1">Constants used in loss recovery are based on a combination of RFCs, papers, and
common practice.<a href="#section-a.2-1" class="pilcrow">¶</a></p>
<span class="break"></span><dl class="dlParallel" id="section-a.2-2">
          <dt id="section-a.2-2.1">kPacketThreshold:</dt>
          <dd style="margin-left: 1.5em" id="section-a.2-2.2">
  Maximum reordering in packets before packet threshold loss detection
considers a packet lost. The value recommended in <a href="#packet-threshold" class="xref">Section 6.1.1</a> is 3.<a href="#section-a.2-2.2" class="pilcrow">¶</a>
</dd>
          <dd class="break"></dd>
<dt id="section-a.2-2.3">kTimeThreshold:</dt>
          <dd style="margin-left: 1.5em" id="section-a.2-2.4">
  Maximum reordering in time before time threshold loss detection
considers a packet lost. Specified as an RTT multiplier. The value
recommended in <a href="#time-threshold" class="xref">Section 6.1.2</a> is 9/8.<a href="#section-a.2-2.4" class="pilcrow">¶</a>
</dd>
          <dd class="break"></dd>
<dt id="section-a.2-2.5">kGranularity:</dt>
          <dd style="margin-left: 1.5em" id="section-a.2-2.6">
  Timer granularity. This is a system-dependent value, and <a href="#time-threshold" class="xref">Section 6.1.2</a>
recommends a value of 1ms.<a href="#section-a.2-2.6" class="pilcrow">¶</a>
</dd>
          <dd class="break"></dd>
<dt id="section-a.2-2.7">kInitialRtt:</dt>
          <dd style="margin-left: 1.5em" id="section-a.2-2.8">
  The RTT used before an RTT sample is taken. The value recommended in
<a href="#pto-handshake" class="xref">Section 6.2.2</a> is 333ms.<a href="#section-a.2-2.8" class="pilcrow">¶</a>
</dd>
          <dd class="break"></dd>
<dt id="section-a.2-2.9">kPacketNumberSpace:</dt>
          <dd style="margin-left: 1.5em" id="section-a.2-2.10">
  An enum to enumerate the three packet number spaces.<a href="#section-a.2-2.10" class="pilcrow">¶</a>
</dd>
        <dd class="break"></dd>
</dl>
<div class="artwork art-text alignLeft" id="section-a.2-3">
<pre>
enum kPacketNumberSpace {
  Initial,
  Handshake,
  ApplicationData,
}
</pre><a href="#section-a.2-3" class="pilcrow">¶</a>
</div>
</section>
</div>
<div id="ld-vars-of-interest">
<section id="section-a.3">
        <h2 id="name-variables-of-interest">
<a href="#section-a.3" class="section-number selfRef">A.3. </a><a href="#name-variables-of-interest" class="section-name selfRef">Variables of interest</a>
        </h2>
<p id="section-a.3-1">Variables required to implement the congestion control mechanisms
are described in this section.<a href="#section-a.3-1" class="pilcrow">¶</a></p>
<span class="break"></span><dl class="dlParallel" id="section-a.3-2">
          <dt id="section-a.3-2.1">latest_rtt:</dt>
          <dd style="margin-left: 1.5em" id="section-a.3-2.2">
  The most recent RTT measurement made when receiving an ack for
a previously unacked packet.<a href="#section-a.3-2.2" class="pilcrow">¶</a>
</dd>
          <dd class="break"></dd>
<dt id="section-a.3-2.3">smoothed_rtt:</dt>
          <dd style="margin-left: 1.5em" id="section-a.3-2.4">
  The smoothed RTT of the connection, computed as described in
<a href="#smoothed-rtt" class="xref">Section 5.3</a>.<a href="#section-a.3-2.4" class="pilcrow">¶</a>
</dd>
          <dd class="break"></dd>
<dt id="section-a.3-2.5">rttvar:</dt>
          <dd style="margin-left: 1.5em" id="section-a.3-2.6">
  The RTT variation, computed as described in <a href="#smoothed-rtt" class="xref">Section 5.3</a>.<a href="#section-a.3-2.6" class="pilcrow">¶</a>
</dd>
          <dd class="break"></dd>
<dt id="section-a.3-2.7">min_rtt:</dt>
          <dd style="margin-left: 1.5em" id="section-a.3-2.8">
  The minimum RTT seen in the connection, ignoring acknowledgment delay, as
described in <a href="#min-rtt" class="xref">Section 5.2</a>.<a href="#section-a.3-2.8" class="pilcrow">¶</a>
</dd>
          <dd class="break"></dd>
<dt id="section-a.3-2.9">first_rtt_sample:</dt>
          <dd style="margin-left: 1.5em" id="section-a.3-2.10">
  The time that the first RTT sample was obtained.<a href="#section-a.3-2.10" class="pilcrow">¶</a>
</dd>
          <dd class="break"></dd>
<dt id="section-a.3-2.11">max_ack_delay:</dt>
          <dd style="margin-left: 1.5em" id="section-a.3-2.12">
  The maximum amount of time by which the receiver intends to delay
acknowledgments for packets in the Application Data packet number
space, as defined by the eponymous transport parameter (Section 18.2
of <span>[<a href="#QUIC-TRANSPORT" class="xref">QUIC-TRANSPORT</a>]</span>). Note that the actual ack_delay in a received
ACK frame may be larger due to late timers, reordering, or loss.<a href="#section-a.3-2.12" class="pilcrow">¶</a>
</dd>
          <dd class="break"></dd>
<dt id="section-a.3-2.13">loss_detection_timer:</dt>
          <dd style="margin-left: 1.5em" id="section-a.3-2.14">
  Multi-modal timer used for loss detection.<a href="#section-a.3-2.14" class="pilcrow">¶</a>
</dd>
          <dd class="break"></dd>
<dt id="section-a.3-2.15">pto_count:</dt>
          <dd style="margin-left: 1.5em" id="section-a.3-2.16">
  The number of times a PTO has been sent without receiving an ack.<a href="#section-a.3-2.16" class="pilcrow">¶</a>
</dd>
          <dd class="break"></dd>
<dt id="section-a.3-2.17">time_of_last_ack_eliciting_packet[kPacketNumberSpace]:</dt>
          <dd style="margin-left: 1.5em" id="section-a.3-2.18">
  The time the most recent ack-eliciting packet was sent.<a href="#section-a.3-2.18" class="pilcrow">¶</a>
</dd>
          <dd class="break"></dd>
<dt id="section-a.3-2.19">largest_acked_packet[kPacketNumberSpace]:</dt>
          <dd style="margin-left: 1.5em" id="section-a.3-2.20">
  The largest packet number acknowledged in the packet number space so far.<a href="#section-a.3-2.20" class="pilcrow">¶</a>
</dd>
          <dd class="break"></dd>
<dt id="section-a.3-2.21">loss_time[kPacketNumberSpace]:</dt>
          <dd style="margin-left: 1.5em" id="section-a.3-2.22">
  The time at which the next packet in that packet number space will be
considered lost based on exceeding the reordering window in time.<a href="#section-a.3-2.22" class="pilcrow">¶</a>
</dd>
          <dd class="break"></dd>
<dt id="section-a.3-2.23">sent_packets[kPacketNumberSpace]:</dt>
          <dd style="margin-left: 1.5em" id="section-a.3-2.24">
  An association of packet numbers in a packet number space to information
about them.  Described in detail above in <a href="#tracking-sent-packets" class="xref">Appendix A.1</a>.<a href="#section-a.3-2.24" class="pilcrow">¶</a>
</dd>
        <dd class="break"></dd>
</dl>
</section>
</div>
<div id="initialization">
<section id="section-a.4">
        <h2 id="name-initialization">
<a href="#section-a.4" class="section-number selfRef">A.4. </a><a href="#name-initialization" class="section-name selfRef">Initialization</a>
        </h2>
<p id="section-a.4-1">At the beginning of the connection, initialize the loss detection variables as
follows:<a href="#section-a.4-1" class="pilcrow">¶</a></p>
<div class="artwork art-text alignLeft" id="section-a.4-2">
<pre>
loss_detection_timer.reset()
pto_count = 0
latest_rtt = 0
smoothed_rtt = kInitialRtt
rttvar = kInitialRtt / 2
min_rtt = 0
first_rtt_sample = 0
for pn_space in [ Initial, Handshake, ApplicationData ]:
  largest_acked_packet[pn_space] = infinite
  time_of_last_ack_eliciting_packet[pn_space] = 0
  loss_time[pn_space] = 0
</pre><a href="#section-a.4-2" class="pilcrow">¶</a>
</div>
</section>
</div>
<div id="on-sending-a-packet">
<section id="section-a.5">
        <h2 id="name-on-sending-a-packet">
<a href="#section-a.5" class="section-number selfRef">A.5. </a><a href="#name-on-sending-a-packet" class="section-name selfRef">On Sending a Packet</a>
        </h2>
<p id="section-a.5-1">After a packet is sent, information about the packet is stored.  The parameters
to OnPacketSent are described in detail above in <a href="#sent-packets-fields" class="xref">Appendix A.1.1</a>.<a href="#section-a.5-1" class="pilcrow">¶</a></p>
<p id="section-a.5-2">Pseudocode for OnPacketSent follows:<a href="#section-a.5-2" class="pilcrow">¶</a></p>
<div class="artwork art-text alignLeft" id="section-a.5-3">
<pre>
OnPacketSent(packet_number, pn_space, ack_eliciting,
             in_flight, sent_bytes):
  sent_packets[pn_space][packet_number].packet_number =
                                           packet_number
  sent_packets[pn_space][packet_number].time_sent = now()
  sent_packets[pn_space][packet_number].ack_eliciting =
                                           ack_eliciting
  sent_packets[pn_space][packet_number].in_flight = in_flight
  if (in_flight):
    if (ack_eliciting):
      time_of_last_ack_eliciting_packet[pn_space] = now()
    OnPacketSentCC(sent_bytes)
    sent_packets[pn_space][packet_number].sent_bytes =
      sent_bytes
    SetLossDetectionTimer()
</pre><a href="#section-a.5-3" class="pilcrow">¶</a>
</div>
</section>
</div>
<div id="on-receiving-a-datagram">
<section id="section-a.6">
        <h2 id="name-on-receiving-a-datagram">
<a href="#section-a.6" class="section-number selfRef">A.6. </a><a href="#name-on-receiving-a-datagram" class="section-name selfRef">On Receiving a Datagram</a>
        </h2>
<p id="section-a.6-1">When a server is blocked by anti-amplification limits, receiving
a datagram unblocks it, even if none of the packets in the
datagram are successfully processed. In such a case, the PTO
timer will need to be re-armed.<a href="#section-a.6-1" class="pilcrow">¶</a></p>
<p id="section-a.6-2">Pseudocode for OnDatagramReceived follows:<a href="#section-a.6-2" class="pilcrow">¶</a></p>
<div class="artwork art-text alignLeft" id="section-a.6-3">
<pre>
OnDatagramReceived(datagram):
  // If this datagram unblocks the server, arm the
  // PTO timer to avoid deadlock.
  if (server was at anti-amplification limit):
    SetLossDetectionTimer()
</pre><a href="#section-a.6-3" class="pilcrow">¶</a>
</div>
</section>
</div>
<div id="on-receiving-an-acknowledgment">
<section id="section-a.7">
        <h2 id="name-on-receiving-an-acknowledgm">
<a href="#section-a.7" class="section-number selfRef">A.7. </a><a href="#name-on-receiving-an-acknowledgm" class="section-name selfRef">On Receiving an Acknowledgment</a>
        </h2>
<p id="section-a.7-1">When an ACK frame is received, it may newly acknowledge any number of packets.<a href="#section-a.7-1" class="pilcrow">¶</a></p>
<p id="section-a.7-2">Pseudocode for OnAckReceived and UpdateRtt follow:<a href="#section-a.7-2" class="pilcrow">¶</a></p>
<div class="artwork art-text alignLeft" id="section-a.7-3">
<pre>
IncludesAckEliciting(packets):
  for packet in packets:
    if (packet.ack_eliciting):
      return true
  return false

OnAckReceived(ack, pn_space):
  if (largest_acked_packet[pn_space] == infinite):
    largest_acked_packet[pn_space] = ack.largest_acked
  else:
    largest_acked_packet[pn_space] =
        max(largest_acked_packet[pn_space], ack.largest_acked)

  // DetectAndRemoveAckedPackets finds packets that are newly
  // acknowledged and removes them from sent_packets.
  newly_acked_packets =
      DetectAndRemoveAckedPackets(ack, pn_space)
  // Nothing to do if there are no newly acked packets.
  if (newly_acked_packets.empty()):
    return

  // Update the RTT if the largest acknowledged is newly acked
  // and at least one ack-eliciting was newly acked.
  if (newly_acked_packets.largest().packet_number ==
          ack.largest_acked &amp;&amp;
      IncludesAckEliciting(newly_acked_packets)):
    latest_rtt =
      now() - newly_acked_packets.largest().time_sent
    UpdateRtt(ack.ack_delay)

  // Process ECN information if present.
  if (ACK frame contains ECN information):
      ProcessECN(ack, pn_space)

  lost_packets = DetectAndRemoveLostPackets(pn_space)
  if (!lost_packets.empty()):
    OnPacketsLost(lost_packets)
  OnPacketsAcked(newly_acked_packets)

  // Reset pto_count unless the client is unsure if
  // the server has validated the client's address.
  if (PeerCompletedAddressValidation()):
    pto_count = 0
  SetLossDetectionTimer()


UpdateRtt(ack_delay):
  if (first_rtt_sample == 0):
    min_rtt = latest_rtt
    smoothed_rtt = latest_rtt
    rttvar = latest_rtt / 2
    first_rtt_sample = now()
    return

  // min_rtt ignores acknowledgment delay.
  min_rtt = min(min_rtt, latest_rtt)
  // Limit ack_delay by max_ack_delay after handshake
  // confirmation. Note that ack_delay is 0 for
  // acknowledgements of Initial and Handshake packets.
  if (handshake confirmed):
    ack_delay = min(ack_delay, max_ack_delay)

  // Adjust for acknowledgment delay if plausible.
  adjusted_rtt = latest_rtt
  if (latest_rtt &gt; min_rtt + ack_delay):
    adjusted_rtt = latest_rtt - ack_delay

  rttvar = 3/4 * rttvar + 1/4 * abs(smoothed_rtt - adjusted_rtt)
  smoothed_rtt = 7/8 * smoothed_rtt + 1/8 * adjusted_rtt
</pre><a href="#section-a.7-3" class="pilcrow">¶</a>
</div>
</section>
</div>
<div id="setting-the-loss-detection-timer">
<section id="section-a.8">
        <h2 id="name-setting-the-loss-detection-">
<a href="#section-a.8" class="section-number selfRef">A.8. </a><a href="#name-setting-the-loss-detection-" class="section-name selfRef">Setting the Loss Detection Timer</a>
        </h2>
<p id="section-a.8-1">QUIC loss detection uses a single timer for all timeout loss detection.  The
duration of the timer is based on the timer's mode, which is set in the packet
and timer events further below.  The function SetLossDetectionTimer defined
below shows how the single timer is set.<a href="#section-a.8-1" class="pilcrow">¶</a></p>
<p id="section-a.8-2">This algorithm may result in the timer being set in the past, particularly if
timers wake up late. Timers set in the past fire immediately.<a href="#section-a.8-2" class="pilcrow">¶</a></p>
<p id="section-a.8-3">Pseudocode for SetLossDetectionTimer follows:<a href="#section-a.8-3" class="pilcrow">¶</a></p>
<div class="artwork art-text alignLeft" id="section-a.8-4">
<pre>
GetLossTimeAndSpace():
  time = loss_time[Initial]
  space = Initial
  for pn_space in [ Handshake, ApplicationData ]:
    if (time == 0 || loss_time[pn_space] &lt; time):
      time = loss_time[pn_space];
      space = pn_space
  return time, space

GetPtoTimeAndSpace():
  duration = (smoothed_rtt + max(4 * rttvar, kGranularity))
      * (2 ^ pto_count)
  // Arm PTO from now when there are no inflight packets.
  if (no in-flight packets):
    assert(!PeerCompletedAddressValidation())
    if (has handshake keys):
      return (now() + duration), Handshake
    else:
      return (now() + duration), Initial
  pto_timeout = infinite
  pto_space = Initial
  for space in [ Initial, Handshake, ApplicationData ]:
    if (no in-flight packets in space):
        continue;
    if (space == ApplicationData):
      // Skip Application Data until handshake confirmed.
      if (handshake is not confirmed):
        return pto_timeout, pto_space
      // Include max_ack_delay and backoff for Application Data.
      duration += max_ack_delay * (2 ^ pto_count)

    t = time_of_last_ack_eliciting_packet[space] + duration
    if (t &lt; pto_timeout):
      pto_timeout = t
      pto_space = space
  return pto_timeout, pto_space

PeerCompletedAddressValidation():
  // Assume clients validate the server's address implicitly.
  if (endpoint is server):
    return true
  // Servers complete address validation when a
  // protected packet is received.
  return has received Handshake ACK ||
       handshake confirmed

SetLossDetectionTimer():
  earliest_loss_time, _ = GetLossTimeAndSpace()
  if (earliest_loss_time != 0):
    // Time threshold loss detection.
    loss_detection_timer.update(earliest_loss_time)
    return

  if (server is at anti-amplification limit):
    // The server's timer is not set if nothing can be sent.
    loss_detection_timer.cancel()
    return

  if (no ack-eliciting packets in flight &amp;&amp;
      PeerCompletedAddressValidation()):
    // There is nothing to detect lost, so no timer is set.
    // However, the client needs to arm the timer if the
    // server might be blocked by the anti-amplification limit.
    loss_detection_timer.cancel()
    return

  // Determine which PN space to arm PTO for.
  timeout, _ = GetPtoTimeAndSpace()
  loss_detection_timer.update(timeout)
</pre><a href="#section-a.8-4" class="pilcrow">¶</a>
</div>
</section>
</div>
<div id="on-timeout">
<section id="section-a.9">
        <h2 id="name-on-timeout">
<a href="#section-a.9" class="section-number selfRef">A.9. </a><a href="#name-on-timeout" class="section-name selfRef">On Timeout</a>
        </h2>
<p id="section-a.9-1">When the loss detection timer expires, the timer's mode determines the action
to be performed.<a href="#section-a.9-1" class="pilcrow">¶</a></p>
<p id="section-a.9-2">Pseudocode for OnLossDetectionTimeout follows:<a href="#section-a.9-2" class="pilcrow">¶</a></p>
<div class="artwork art-text alignLeft" id="section-a.9-3">
<pre>
OnLossDetectionTimeout():
  earliest_loss_time, pn_space = GetLossTimeAndSpace()
  if (earliest_loss_time != 0):
    // Time threshold loss Detection
    lost_packets = DetectAndRemoveLostPackets(pn_space)
    assert(!lost_packets.empty())
    OnPacketsLost(lost_packets)
    SetLossDetectionTimer()
    return

  if (bytes_in_flight &gt; 0):
    // PTO. Send new data if available, else retransmit old data.
    // If neither is available, send a single PING frame.
    _, pn_space = GetPtoTimeAndSpace()
    SendOneOrTwoAckElicitingPackets(pn_space)
  else:
    assert(!PeerCompletedAddressValidation())
    // Client sends an anti-deadlock packet: Initial is padded
    // to earn more anti-amplification credit,
    // a Handshake packet proves address ownership.
    if (has Handshake keys):
      SendOneAckElicitingHandshakePacket()
    else:
      SendOneAckElicitingPaddedInitialPacket()

  pto_count++
  SetLossDetectionTimer()
</pre><a href="#section-a.9-3" class="pilcrow">¶</a>
</div>
</section>
</div>
<div id="detecting-lost-packets">
<section id="section-a.10">
        <h2 id="name-detecting-lost-packets">
<a href="#section-a.10" class="section-number selfRef">A.10. </a><a href="#name-detecting-lost-packets" class="section-name selfRef">Detecting Lost Packets</a>
        </h2>
<p id="section-a.10-1">DetectAndRemoveLostPackets is called every time an ACK is received or the time
threshold loss detection timer expires. This function operates on the
sent_packets for that packet number space and returns a list of packets newly
detected as lost.<a href="#section-a.10-1" class="pilcrow">¶</a></p>
<p id="section-a.10-2">Pseudocode for DetectAndRemoveLostPackets follows:<a href="#section-a.10-2" class="pilcrow">¶</a></p>
<div class="artwork art-text alignLeft" id="section-a.10-3">
<pre>
DetectAndRemoveLostPackets(pn_space):
  assert(largest_acked_packet[pn_space] != infinite)
  loss_time[pn_space] = 0
  lost_packets = []
  loss_delay = kTimeThreshold * max(latest_rtt, smoothed_rtt)

  // Minimum time of kGranularity before packets are deemed lost.
  loss_delay = max(loss_delay, kGranularity)

  // Packets sent before this time are deemed lost.
  lost_send_time = now() - loss_delay

  foreach unacked in sent_packets[pn_space]:
    if (unacked.packet_number &gt; largest_acked_packet[pn_space]):
      continue

    // Mark packet as lost, or set time when it should be marked.
    // Note: The use of kPacketThreshold here assumes that there
    // were no sender-induced gaps in the packet number space.
    if (unacked.time_sent &lt;= lost_send_time ||
        largest_acked_packet[pn_space] &gt;=
          unacked.packet_number + kPacketThreshold):
      sent_packets[pn_space].remove(unacked.packet_number)
      if (unacked.in_flight):
        lost_packets.insert(unacked)
    else:
      if (loss_time[pn_space] == 0):
        loss_time[pn_space] = unacked.time_sent + loss_delay
      else:
        loss_time[pn_space] = min(loss_time[pn_space],
                                  unacked.time_sent + loss_delay)
  return lost_packets
</pre><a href="#section-a.10-3" class="pilcrow">¶</a>
</div>
</section>
</div>
<div id="upon-dropping-initial-or-handshake-keys">
<section id="section-a.11">
        <h2 id="name-upon-dropping-initial-or-ha">
<a href="#section-a.11" class="section-number selfRef">A.11. </a><a href="#name-upon-dropping-initial-or-ha" class="section-name selfRef">Upon Dropping Initial or Handshake Keys</a>
        </h2>
<p id="section-a.11-1">When Initial or Handshake keys are discarded, packets from the space
are discarded and loss detection state is updated.<a href="#section-a.11-1" class="pilcrow">¶</a></p>
<p id="section-a.11-2">Pseudocode for OnPacketNumberSpaceDiscarded follows:<a href="#section-a.11-2" class="pilcrow">¶</a></p>
<div class="artwork art-text alignLeft" id="section-a.11-3">
<pre>
OnPacketNumberSpaceDiscarded(pn_space):
  assert(pn_space != ApplicationData)
  RemoveFromBytesInFlight(sent_packets[pn_space])
  sent_packets[pn_space].clear()
  // Reset the loss detection and PTO timer
  time_of_last_ack_eliciting_packet[pn_space] = 0
  loss_time[pn_space] = 0
  pto_count = 0
  SetLossDetectionTimer()
</pre><a href="#section-a.11-3" class="pilcrow">¶</a>
</div>
</section>
</div>
</section>
</div>
<div id="congestion-control-pseudocode">
<section id="section-appendix.b">
      <h2 id="name-congestion-control-pseudoco">
<a href="#section-appendix.b" class="section-number selfRef">Appendix B. </a><a href="#name-congestion-control-pseudoco" class="section-name selfRef">Congestion Control Pseudocode</a>
      </h2>
<p id="section-appendix.b-1">We now describe an example implementation of the congestion controller described
in <a href="#congestion-control" class="xref">Section 7</a>.<a href="#section-appendix.b-1" class="pilcrow">¶</a></p>
<p id="section-appendix.b-2">The pseudocode segments in this section are licensed as Code Components; see the
copyright notice.<a href="#section-appendix.b-2" class="pilcrow">¶</a></p>
<div id="cc-consts-of-interest">
<section id="section-b.1">
        <h2 id="name-constants-of-interest-2">
<a href="#section-b.1" class="section-number selfRef">B.1. </a><a href="#name-constants-of-interest-2" class="section-name selfRef">Constants of interest</a>
        </h2>
<p id="section-b.1-1">Constants used in congestion control are based on a combination of RFCs, papers,
and common practice.<a href="#section-b.1-1" class="pilcrow">¶</a></p>
<span class="break"></span><dl class="dlParallel" id="section-b.1-2">
          <dt id="section-b.1-2.1">kInitialWindow:</dt>
          <dd style="margin-left: 1.5em" id="section-b.1-2.2">
  Default limit on the initial bytes in flight as described in <a href="#initial-cwnd" class="xref">Section 7.2</a>.<a href="#section-b.1-2.2" class="pilcrow">¶</a>
</dd>
          <dd class="break"></dd>
<dt id="section-b.1-2.3">kMinimumWindow:</dt>
          <dd style="margin-left: 1.5em" id="section-b.1-2.4">
  Minimum congestion window in bytes as described in <a href="#initial-cwnd" class="xref">Section 7.2</a>.<a href="#section-b.1-2.4" class="pilcrow">¶</a>
</dd>
          <dd class="break"></dd>
<dt id="section-b.1-2.5">kLossReductionFactor:</dt>
          <dd style="margin-left: 1.5em" id="section-b.1-2.6">
  Reduction in congestion window when a new loss event is detected.
<a href="#congestion-control" class="xref">Section 7</a> recommends a value is 0.5.<a href="#section-b.1-2.6" class="pilcrow">¶</a>
</dd>
          <dd class="break"></dd>
<dt id="section-b.1-2.7">kPersistentCongestionThreshold:</dt>
          <dd style="margin-left: 1.5em" id="section-b.1-2.8">
  Period of time for persistent congestion to be established, specified as a PTO
multiplier. <a href="#persistent-congestion" class="xref">Section 7.6</a> recommends a value of 3.<a href="#section-b.1-2.8" class="pilcrow">¶</a>
</dd>
        <dd class="break"></dd>
</dl>
</section>
</div>
<div id="vars-of-interest">
<section id="section-b.2">
        <h2 id="name-variables-of-interest-2">
<a href="#section-b.2" class="section-number selfRef">B.2. </a><a href="#name-variables-of-interest-2" class="section-name selfRef">Variables of interest</a>
        </h2>
<p id="section-b.2-1">Variables required to implement the congestion control mechanisms
are described in this section.<a href="#section-b.2-1" class="pilcrow">¶</a></p>
<span class="break"></span><dl class="dlParallel" id="section-b.2-2">
          <dt id="section-b.2-2.1">max_datagram_size:</dt>
          <dd style="margin-left: 1.5em" id="section-b.2-2.2">
  The sender's current maximum payload size. Does not include UDP or IP
overhead.  The max datagram size is used for congestion window
computations. An endpoint sets the value of this variable based on its Path
Maximum Transmission Unit (PMTU; see Section 14.2 of <span>[<a href="#QUIC-TRANSPORT" class="xref">QUIC-TRANSPORT</a>]</span>), with
a minimum value of 1200 bytes.<a href="#section-b.2-2.2" class="pilcrow">¶</a>
</dd>
          <dd class="break"></dd>
<dt id="section-b.2-2.3">ecn_ce_counters[kPacketNumberSpace]:</dt>
          <dd style="margin-left: 1.5em" id="section-b.2-2.4">
  The highest value reported for the ECN-CE counter in the packet number space
by the peer in an ACK frame. This value is used to detect increases in the
reported ECN-CE counter.<a href="#section-b.2-2.4" class="pilcrow">¶</a>
</dd>
          <dd class="break"></dd>
<dt id="section-b.2-2.5">bytes_in_flight:</dt>
          <dd style="margin-left: 1.5em" id="section-b.2-2.6">
  The sum of the size in bytes of all sent packets that contain at least one
ack-eliciting or PADDING frame, and have not been acknowledged or declared
lost. The size does not include IP or UDP overhead, but does include the QUIC
header and AEAD overhead.  Packets only containing ACK frames do not count
towards bytes_in_flight to ensure congestion control does not impede
congestion feedback.<a href="#section-b.2-2.6" class="pilcrow">¶</a>
</dd>
          <dd class="break"></dd>
<dt id="section-b.2-2.7">congestion_window:</dt>
          <dd style="margin-left: 1.5em" id="section-b.2-2.8">
  Maximum number of bytes-in-flight that may be sent.<a href="#section-b.2-2.8" class="pilcrow">¶</a>
</dd>
          <dd class="break"></dd>
<dt id="section-b.2-2.9">congestion_recovery_start_time:</dt>
          <dd style="margin-left: 1.5em" id="section-b.2-2.10">
  The time when QUIC first detects congestion due to loss or ECN, causing
it to enter congestion recovery. When a packet sent after this time is
acknowledged, QUIC exits congestion recovery.<a href="#section-b.2-2.10" class="pilcrow">¶</a>
</dd>
          <dd class="break"></dd>
<dt id="section-b.2-2.11">ssthresh:</dt>
          <dd style="margin-left: 1.5em" id="section-b.2-2.12">
  Slow start threshold in bytes.  When the congestion window is below ssthresh,
the mode is slow start and the window grows by the number of bytes
acknowledged.<a href="#section-b.2-2.12" class="pilcrow">¶</a>
</dd>
        <dd class="break"></dd>
</dl>
<p id="section-b.2-3">The congestion control pseudocode also accesses some of the variables from the
loss recovery pseudocode.<a href="#section-b.2-3" class="pilcrow">¶</a></p>
</section>
</div>
<div id="initialization-1">
<section id="section-b.3">
        <h2 id="name-initialization-2">
<a href="#section-b.3" class="section-number selfRef">B.3. </a><a href="#name-initialization-2" class="section-name selfRef">Initialization</a>
        </h2>
<p id="section-b.3-1">At the beginning of the connection, initialize the congestion control
variables as follows:<a href="#section-b.3-1" class="pilcrow">¶</a></p>
<div class="artwork art-text alignLeft" id="section-b.3-2">
<pre>
congestion_window = kInitialWindow
bytes_in_flight = 0
congestion_recovery_start_time = 0
ssthresh = infinite
for pn_space in [ Initial, Handshake, ApplicationData ]:
  ecn_ce_counters[pn_space] = 0
</pre><a href="#section-b.3-2" class="pilcrow">¶</a>
</div>
</section>
</div>
<div id="on-packet-sent">
<section id="section-b.4">
        <h2 id="name-on-packet-sent">
<a href="#section-b.4" class="section-number selfRef">B.4. </a><a href="#name-on-packet-sent" class="section-name selfRef">On Packet Sent</a>
        </h2>
<p id="section-b.4-1">Whenever a packet is sent, and it contains non-ACK frames, the packet
increases bytes_in_flight.<a href="#section-b.4-1" class="pilcrow">¶</a></p>
<div class="artwork art-text alignLeft" id="section-b.4-2">
<pre>
OnPacketSentCC(bytes_sent):
  bytes_in_flight += bytes_sent
</pre><a href="#section-b.4-2" class="pilcrow">¶</a>
</div>
</section>
</div>
<div id="on-packet-acknowledgement">
<section id="section-b.5">
        <h2 id="name-on-packet-acknowledgement">
<a href="#section-b.5" class="section-number selfRef">B.5. </a><a href="#name-on-packet-acknowledgement" class="section-name selfRef">On Packet Acknowledgement</a>
        </h2>
<p id="section-b.5-1">Invoked from loss detection's OnAckReceived and is supplied with the
newly acked_packets from sent_packets.<a href="#section-b.5-1" class="pilcrow">¶</a></p>
<p id="section-b.5-2">In congestion avoidance, implementers that use an integer representation
for congestion_window should be careful with division, and can use
the alternative approach suggested in Section 2.1 of <span>[<a href="#RFC3465" class="xref">RFC3465</a>]</span>.<a href="#section-b.5-2" class="pilcrow">¶</a></p>
<div class="artwork art-text alignLeft" id="section-b.5-3">
<pre>
InCongestionRecovery(sent_time):
  return sent_time &lt;= congestion_recovery_start_time

OnPacketsAcked(acked_packets):
  for acked_packet in acked_packets:
    OnPacketAcked(acked_packet)

OnPacketAcked(acked_packet):
  // Remove from bytes_in_flight.
  bytes_in_flight -= acked_packet.sent_bytes
  // Do not increase congestion_window if application
  // limited or flow control limited.
  if (IsAppOrFlowControlLimited())
    return
  // Do not increase congestion window in recovery period.
  if (InCongestionRecovery(acked_packet.time_sent)):
    return
  if (congestion_window &lt; ssthresh):
    // Slow start.
    congestion_window += acked_packet.sent_bytes
  else:
    // Congestion avoidance.
    congestion_window +=
      max_datagram_size * acked_packet.sent_bytes
      / congestion_window
</pre><a href="#section-b.5-3" class="pilcrow">¶</a>
</div>
</section>
</div>
<div id="on-new-congestion-event">
<section id="section-b.6">
        <h2 id="name-on-new-congestion-event">
<a href="#section-b.6" class="section-number selfRef">B.6. </a><a href="#name-on-new-congestion-event" class="section-name selfRef">On New Congestion Event</a>
        </h2>
<p id="section-b.6-1">Invoked from ProcessECN and OnPacketsLost when a new congestion event is
detected. If not already in recovery, this starts a recovery period and
reduces the slow start threshold and congestion window immediately.<a href="#section-b.6-1" class="pilcrow">¶</a></p>
<div class="artwork art-text alignLeft" id="section-b.6-2">
<pre>
OnCongestionEvent(sent_time):
  // No reaction if already in a recovery period.
  if (InCongestionRecovery(sent_time)):
    return

  // Enter recovery period.
  congestion_recovery_start_time = now()
  ssthresh = congestion_window * kLossReductionFactor
  congestion_window = max(ssthresh, kMinimumWindow)
  // A packet can be sent to speed up loss recovery.
  MaybeSendOnePacket()
</pre><a href="#section-b.6-2" class="pilcrow">¶</a>
</div>
</section>
</div>
<div id="process-ecn-information">
<section id="section-b.7">
        <h2 id="name-process-ecn-information">
<a href="#section-b.7" class="section-number selfRef">B.7. </a><a href="#name-process-ecn-information" class="section-name selfRef">Process ECN Information</a>
        </h2>
<p id="section-b.7-1">Invoked when an ACK frame with an ECN section is received from the peer.<a href="#section-b.7-1" class="pilcrow">¶</a></p>
<div class="artwork art-text alignLeft" id="section-b.7-2">
<pre>
ProcessECN(ack, pn_space):
  // If the ECN-CE counter reported by the peer has increased,
  // this could be a new congestion event.
  if (ack.ce_counter &gt; ecn_ce_counters[pn_space]):
    ecn_ce_counters[pn_space] = ack.ce_counter
    sent_time = sent_packets[ack.largest_acked].time_sent
    OnCongestionEvent(sent_time)
</pre><a href="#section-b.7-2" class="pilcrow">¶</a>
</div>
</section>
</div>
<div id="on-packets-lost">
<section id="section-b.8">
        <h2 id="name-on-packets-lost">
<a href="#section-b.8" class="section-number selfRef">B.8. </a><a href="#name-on-packets-lost" class="section-name selfRef">On Packets Lost</a>
        </h2>
<p id="section-b.8-1">Invoked when DetectAndRemoveLostPackets deems packets lost.<a href="#section-b.8-1" class="pilcrow">¶</a></p>
<div class="artwork art-text alignLeft" id="section-b.8-2">
<pre>
OnPacketsLost(lost_packets):
  // Remove lost packets from bytes_in_flight.
  for lost_packet in lost_packets:
    bytes_in_flight -= lost_packet.sent_bytes
  OnCongestionEvent(lost_packets.largest().time_sent)

  // Reset the congestion window if the loss of these
  // packets indicates persistent congestion.
  // Only consider packets sent after getting an RTT sample.
  if (first_rtt_sample == 0):
    return
  pc_lost = []
  for lost in lost_packets:
    if lost.time_sent &gt; first_rtt_sample:
      pc_lost.insert(lost)
  if (InPersistentCongestion(pc_lost)):
    congestion_window = kMinimumWindow
    congestion_recovery_start_time = 0
</pre><a href="#section-b.8-2" class="pilcrow">¶</a>
</div>
</section>
</div>
<div id="removing-discarded-packets-from-bytes-in-flight">
<section id="section-b.9">
        <h2 id="name-removing-discarded-packets-">
<a href="#section-b.9" class="section-number selfRef">B.9. </a><a href="#name-removing-discarded-packets-" class="section-name selfRef">Removing Discarded Packets From Bytes In Flight</a>
        </h2>
<p id="section-b.9-1">When Initial or Handshake keys are discarded, packets sent in that space no
longer count toward bytes in flight.<a href="#section-b.9-1" class="pilcrow">¶</a></p>
<p id="section-b.9-2">Pseudocode for RemoveFromBytesInFlight follows:<a href="#section-b.9-2" class="pilcrow">¶</a></p>
<div class="artwork art-text alignLeft" id="section-b.9-3">
<pre>
RemoveFromBytesInFlight(discarded_packets):
  // Remove any unacknowledged packets from flight.
  foreach packet in discarded_packets:
    if packet.in_flight
      bytes_in_flight -= size
</pre><a href="#section-b.9-3" class="pilcrow">¶</a>
</div>
</section>
</div>
</section>
</div>
<div id="change-log">
<section id="section-appendix.c">
      <h2 id="name-change-log">
<a href="#section-appendix.c" class="section-number selfRef">Appendix C. </a><a href="#name-change-log" class="section-name selfRef">Change Log</a>
      </h2>
<ul class="normal ulEmpty">
<li class="normal ulEmpty" id="section-appendix.c-1.1">
          <strong>RFC Editor's Note:</strong>  Please remove this section prior to
publication of a final version of this document.<a href="#section-appendix.c-1.1" class="pilcrow">¶</a>
</li>
      </ul>
<p id="section-appendix.c-2">Issue and pull request numbers are listed with a leading octothorp.<a href="#section-appendix.c-2" class="pilcrow">¶</a></p>
<div id="since-draft-ietf-quic-recovery-31">
<section id="section-c.1">
        <h2 id="name-since-draft-ietf-quic-recov">
<a href="#section-c.1" class="section-number selfRef">C.1. </a><a href="#name-since-draft-ietf-quic-recov" class="section-name selfRef">Since draft-ietf-quic-recovery-31</a>
        </h2>
<ul class="normal">
<li class="normal" id="section-c.1-1.1">Limit the number of Initial packets sent in response to unauthenticated
packets (#4183, #4188)<a href="#section-c.1-1.1" class="pilcrow">¶</a>
</li>
        </ul>
</section>
</div>
<div id="since-draft-ietf-quic-recovery-30">
<section id="section-c.2">
        <h2 id="name-since-draft-ietf-quic-recove">
<a href="#section-c.2" class="section-number selfRef">C.2. </a><a href="#name-since-draft-ietf-quic-recove" class="section-name selfRef">Since draft-ietf-quic-recovery-30</a>
        </h2>
<p id="section-c.2-1">Editorial changes only.<a href="#section-c.2-1" class="pilcrow">¶</a></p>
</section>
</div>
<div id="since-draft-ietf-quic-recovery-29">
<section id="section-c.3">
        <h2 id="name-since-draft-ietf-quic-recover">
<a href="#section-c.3" class="section-number selfRef">C.3. </a><a href="#name-since-draft-ietf-quic-recover" class="section-name selfRef">Since draft-ietf-quic-recovery-29</a>
        </h2>
<ul class="normal">
<li class="normal" id="section-c.3-1.1">Allow caching of packets that can't be decrypted, by allowing the reported
acknowledgment delay to exceed max_ack_delay prior to confirming the
handshake (#3821, #3980, #4035, #3874)<a href="#section-c.3-1.1" class="pilcrow">¶</a>
</li>
          <li class="normal" id="section-c.3-1.2">Persistent congestion cannot include packets sent before the first RTT
sample for the path (#3875, #3889)<a href="#section-c.3-1.2" class="pilcrow">¶</a>
</li>
          <li class="normal" id="section-c.3-1.3">Recommend reset of min_rtt in persistent congestion (#3927, #3975)<a href="#section-c.3-1.3" class="pilcrow">¶</a>
</li>
          <li class="normal" id="section-c.3-1.4">Persistent congestion is independent of packet number space (#3939, #3961)<a href="#section-c.3-1.4" class="pilcrow">¶</a>
</li>
          <li class="normal" id="section-c.3-1.5">Only limit bursts to the initial window without information about the path
(#3892, #3936)<a href="#section-c.3-1.5" class="pilcrow">¶</a>
</li>
          <li class="normal" id="section-c.3-1.6">Add normative requirements for increasing and reducing the congestion
window (#3944, #3978, #3997, #3998)<a href="#section-c.3-1.6" class="pilcrow">¶</a>
</li>
        </ul>
</section>
</div>
<div id="since-draft-ietf-quic-recovery-28">
<section id="section-c.4">
        <h2 id="name-since-draft-ietf-quic-recovery">
<a href="#section-c.4" class="section-number selfRef">C.4. </a><a href="#name-since-draft-ietf-quic-recovery" class="section-name selfRef">Since draft-ietf-quic-recovery-28</a>
        </h2>
<ul class="normal">
<li class="normal" id="section-c.4-1.1">Refactored pseudocode to correct PTO calculation (#3564, #3674, #3681)<a href="#section-c.4-1.1" class="pilcrow">¶</a>
</li>
        </ul>
</section>
</div>
<div id="since-draft-ietf-quic-recovery-27">
<section id="section-c.5">
        <h2 id="name-since-draft-ietf-quic-recovery-">
<a href="#section-c.5" class="section-number selfRef">C.5. </a><a href="#name-since-draft-ietf-quic-recovery-" class="section-name selfRef">Since draft-ietf-quic-recovery-27</a>
        </h2>
<ul class="normal">
<li class="normal" id="section-c.5-1.1">Added recommendations for speeding up handshake under some loss conditions
(#3078, #3080)<a href="#section-c.5-1.1" class="pilcrow">¶</a>
</li>
          <li class="normal" id="section-c.5-1.2">PTO count is reset when handshake progress is made (#3272, #3415)<a href="#section-c.5-1.2" class="pilcrow">¶</a>
</li>
          <li class="normal" id="section-c.5-1.3">PTO count is not reset by a client when the server might be awaiting
address validation (#3546, #3551)<a href="#section-c.5-1.3" class="pilcrow">¶</a>
</li>
          <li class="normal" id="section-c.5-1.4">Recommend repairing losses immediately after entering the recovery period
(#3335, #3443)<a href="#section-c.5-1.4" class="pilcrow">¶</a>
</li>
          <li class="normal" id="section-c.5-1.5">Clarified what loss conditions can be ignored during the handshake (#3456,
#3450)<a href="#section-c.5-1.5" class="pilcrow">¶</a>
</li>
          <li class="normal" id="section-c.5-1.6">Allow, but don't recommend, using RTT from previous connection to seed RTT
(#3464, #3496)<a href="#section-c.5-1.6" class="pilcrow">¶</a>
</li>
          <li class="normal" id="section-c.5-1.7">Recommend use of adaptive loss detection thresholds (#3571, #3572)<a href="#section-c.5-1.7" class="pilcrow">¶</a>
</li>
        </ul>
</section>
</div>
<div id="since-draft-ietf-quic-recovery-26">
<section id="section-c.6">
        <h2 id="name-since-draft-ietf-quic-recovery-2">
<a href="#section-c.6" class="section-number selfRef">C.6. </a><a href="#name-since-draft-ietf-quic-recovery-2" class="section-name selfRef">Since draft-ietf-quic-recovery-26</a>
        </h2>
<p id="section-c.6-1">No changes.<a href="#section-c.6-1" class="pilcrow">¶</a></p>
</section>
</div>
<div id="since-draft-ietf-quic-recovery-25">
<section id="section-c.7">
        <h2 id="name-since-draft-ietf-quic-recovery-25">
<a href="#section-c.7" class="section-number selfRef">C.7. </a><a href="#name-since-draft-ietf-quic-recovery-25" class="section-name selfRef">Since draft-ietf-quic-recovery-25</a>
        </h2>
<p id="section-c.7-1">No significant changes.<a href="#section-c.7-1" class="pilcrow">¶</a></p>
</section>
</div>
<div id="since-draft-ietf-quic-recovery-24">
<section id="section-c.8">
        <h2 id="name-since-draft-ietf-quic-recovery-24">
<a href="#section-c.8" class="section-number selfRef">C.8. </a><a href="#name-since-draft-ietf-quic-recovery-24" class="section-name selfRef">Since draft-ietf-quic-recovery-24</a>
        </h2>
<ul class="normal">
<li class="normal" id="section-c.8-1.1">Require congestion control of some sort (#3247, #3244, #3248)<a href="#section-c.8-1.1" class="pilcrow">¶</a>
</li>
          <li class="normal" id="section-c.8-1.2">Set a minimum reordering threshold (#3256, #3240)<a href="#section-c.8-1.2" class="pilcrow">¶</a>
</li>
          <li class="normal" id="section-c.8-1.3">PTO is specific to a packet number space (#3067, #3074, #3066)<a href="#section-c.8-1.3" class="pilcrow">¶</a>
</li>
        </ul>
</section>
</div>
<div id="since-draft-ietf-quic-recovery-23">
<section id="section-c.9">
        <h2 id="name-since-draft-ietf-quic-recovery-23">
<a href="#section-c.9" class="section-number selfRef">C.9. </a><a href="#name-since-draft-ietf-quic-recovery-23" class="section-name selfRef">Since draft-ietf-quic-recovery-23</a>
        </h2>
<ul class="normal">
<li class="normal" id="section-c.9-1.1">Define under-utilizing the congestion window (#2630, #2686, #2675)<a href="#section-c.9-1.1" class="pilcrow">¶</a>
</li>
          <li class="normal" id="section-c.9-1.2">PTO MUST send data if possible (#3056, #3057)<a href="#section-c.9-1.2" class="pilcrow">¶</a>
</li>
          <li class="normal" id="section-c.9-1.3">Connection Close is not ack-eliciting (#3097, #3098)<a href="#section-c.9-1.3" class="pilcrow">¶</a>
</li>
          <li class="normal" id="section-c.9-1.4">MUST limit bursts to the initial congestion window (#3160)<a href="#section-c.9-1.4" class="pilcrow">¶</a>
</li>
          <li class="normal" id="section-c.9-1.5">Define the current max_datagram_size for congestion control
(#3041, #3167)<a href="#section-c.9-1.5" class="pilcrow">¶</a>
</li>
        </ul>
</section>
</div>
<div id="since-draft-ietf-quic-recovery-22">
<section id="section-c.10">
        <h2 id="name-since-draft-ietf-quic-recovery-22">
<a href="#section-c.10" class="section-number selfRef">C.10. </a><a href="#name-since-draft-ietf-quic-recovery-22" class="section-name selfRef">Since draft-ietf-quic-recovery-22</a>
        </h2>
<ul class="normal">
<li class="normal" id="section-c.10-1.1">PTO should always send an ack-eliciting packet (#2895)<a href="#section-c.10-1.1" class="pilcrow">¶</a>
</li>
          <li class="normal" id="section-c.10-1.2">Unify the Handshake Timer with the PTO timer (#2648, #2658, #2886)<a href="#section-c.10-1.2" class="pilcrow">¶</a>
</li>
          <li class="normal" id="section-c.10-1.3">Move ACK generation text to transport draft (#1860, #2916)<a href="#section-c.10-1.3" class="pilcrow">¶</a>
</li>
        </ul>
</section>
</div>
<div id="since-draft-ietf-quic-recovery-21">
<section id="section-c.11">
        <h2 id="name-since-draft-ietf-quic-recovery-21">
<a href="#section-c.11" class="section-number selfRef">C.11. </a><a href="#name-since-draft-ietf-quic-recovery-21" class="section-name selfRef">Since draft-ietf-quic-recovery-21</a>
        </h2>
<ul class="normal">
<li class="normal" id="section-c.11-1.1">No changes<a href="#section-c.11-1.1" class="pilcrow">¶</a>
</li>
        </ul>
</section>
</div>
<div id="since-draft-ietf-quic-recovery-20">
<section id="section-c.12">
        <h2 id="name-since-draft-ietf-quic-recovery-20">
<a href="#section-c.12" class="section-number selfRef">C.12. </a><a href="#name-since-draft-ietf-quic-recovery-20" class="section-name selfRef">Since draft-ietf-quic-recovery-20</a>
        </h2>
<ul class="normal">
<li class="normal" id="section-c.12-1.1">Path validation can be used as initial RTT value (#2644, #2687)<a href="#section-c.12-1.1" class="pilcrow">¶</a>
</li>
          <li class="normal" id="section-c.12-1.2">max_ack_delay transport parameter defaults to 0 (#2638, #2646)<a href="#section-c.12-1.2" class="pilcrow">¶</a>
</li>
          <li class="normal" id="section-c.12-1.3">ACK delay only measures intentional delays induced by the implementation
(#2596, #2786)<a href="#section-c.12-1.3" class="pilcrow">¶</a>
</li>
        </ul>
</section>
</div>
<div id="since-draft-ietf-quic-recovery-19">
<section id="section-c.13">
        <h2 id="name-since-draft-ietf-quic-recovery-1">
<a href="#section-c.13" class="section-number selfRef">C.13. </a><a href="#name-since-draft-ietf-quic-recovery-1" class="section-name selfRef">Since draft-ietf-quic-recovery-19</a>
        </h2>
<ul class="normal">
<li class="normal" id="section-c.13-1.1">Change kPersistentThreshold from an exponent to a multiplier (#2557)<a href="#section-c.13-1.1" class="pilcrow">¶</a>
</li>
          <li class="normal" id="section-c.13-1.2">Send a PING if the PTO timer fires and there's nothing to send (#2624)<a href="#section-c.13-1.2" class="pilcrow">¶</a>
</li>
          <li class="normal" id="section-c.13-1.3">Set loss delay to at least kGranularity (#2617)<a href="#section-c.13-1.3" class="pilcrow">¶</a>
</li>
          <li class="normal" id="section-c.13-1.4">Merge application limited and sending after idle sections. Always limit
burst size instead of requiring resetting CWND to initial CWND after
idle (#2605)<a href="#section-c.13-1.4" class="pilcrow">¶</a>
</li>
          <li class="normal" id="section-c.13-1.5">Rewrite RTT estimation, allow RTT samples where a newly acked packet is
ack-eliciting but the largest_acked is not (#2592)<a href="#section-c.13-1.5" class="pilcrow">¶</a>
</li>
          <li class="normal" id="section-c.13-1.6">Don't arm the handshake timer if there is no handshake data (#2590)<a href="#section-c.13-1.6" class="pilcrow">¶</a>
</li>
          <li class="normal" id="section-c.13-1.7">Clarify that the time threshold loss alarm takes precedence over the
crypto handshake timer (#2590, #2620)<a href="#section-c.13-1.7" class="pilcrow">¶</a>
</li>
          <li class="normal" id="section-c.13-1.8">Change initial RTT to 500ms to align with RFC6298 (#2184)<a href="#section-c.13-1.8" class="pilcrow">¶</a>
</li>
        </ul>
</section>
</div>
<div id="since-draft-ietf-quic-recovery-18">
<section id="section-c.14">
        <h2 id="name-since-draft-ietf-quic-recovery-18">
<a href="#section-c.14" class="section-number selfRef">C.14. </a><a href="#name-since-draft-ietf-quic-recovery-18" class="section-name selfRef">Since draft-ietf-quic-recovery-18</a>
        </h2>
<ul class="normal">
<li class="normal" id="section-c.14-1.1">Change IW byte limit to 14720 from 14600 (#2494)<a href="#section-c.14-1.1" class="pilcrow">¶</a>
</li>
          <li class="normal" id="section-c.14-1.2">Update PTO calculation to match RFC6298 (#2480, #2489, #2490)<a href="#section-c.14-1.2" class="pilcrow">¶</a>
</li>
          <li class="normal" id="section-c.14-1.3">Improve loss detection's description of multiple packet number spaces and
pseudocode (#2485, #2451, #2417)<a href="#section-c.14-1.3" class="pilcrow">¶</a>
</li>
          <li class="normal" id="section-c.14-1.4">Declare persistent congestion even if non-probe packets are sent and don't
make persistent congestion more aggressive than RTO verified was (#2365,
#2244)<a href="#section-c.14-1.4" class="pilcrow">¶</a>
</li>
          <li class="normal" id="section-c.14-1.5">Move pseudocode to the appendices (#2408)<a href="#section-c.14-1.5" class="pilcrow">¶</a>
</li>
          <li class="normal" id="section-c.14-1.6">What to send on multiple PTOs (#2380)<a href="#section-c.14-1.6" class="pilcrow">¶</a>
</li>
        </ul>
</section>
</div>
<div id="since-draft-ietf-quic-recovery-17">
<section id="section-c.15">
        <h2 id="name-since-draft-ietf-quic-recovery-17">
<a href="#section-c.15" class="section-number selfRef">C.15. </a><a href="#name-since-draft-ietf-quic-recovery-17" class="section-name selfRef">Since draft-ietf-quic-recovery-17</a>
        </h2>
<ul class="normal">
<li class="normal" id="section-c.15-1.1">After Probe Timeout discard in-flight packets or send another (#2212, #1965)<a href="#section-c.15-1.1" class="pilcrow">¶</a>
</li>
          <li class="normal" id="section-c.15-1.2">Endpoints discard initial keys as soon as handshake keys are available (#1951,
#2045)<a href="#section-c.15-1.2" class="pilcrow">¶</a>
</li>
          <li class="normal" id="section-c.15-1.3">0-RTT state is discarded when 0-RTT is rejected (#2300)<a href="#section-c.15-1.3" class="pilcrow">¶</a>
</li>
          <li class="normal" id="section-c.15-1.4">Loss detection timer is cancelled when ack-eliciting frames are in flight
(#2117, #2093)<a href="#section-c.15-1.4" class="pilcrow">¶</a>
</li>
          <li class="normal" id="section-c.15-1.5">Packets are declared lost if they are in flight (#2104)<a href="#section-c.15-1.5" class="pilcrow">¶</a>
</li>
          <li class="normal" id="section-c.15-1.6">After becoming idle, either pace packets or reset the congestion controller
(#2138, 2187)<a href="#section-c.15-1.6" class="pilcrow">¶</a>
</li>
          <li class="normal" id="section-c.15-1.7">Process ECN counts before marking packets lost (#2142)<a href="#section-c.15-1.7" class="pilcrow">¶</a>
</li>
          <li class="normal" id="section-c.15-1.8">Mark packets lost before resetting crypto_count and pto_count (#2208, #2209)<a href="#section-c.15-1.8" class="pilcrow">¶</a>
</li>
          <li class="normal" id="section-c.15-1.9">Congestion and loss recovery state are discarded when keys are discarded
(#2327)<a href="#section-c.15-1.9" class="pilcrow">¶</a>
</li>
        </ul>
</section>
</div>
<div id="since-draft-ietf-quic-recovery-16">
<section id="section-c.16">
        <h2 id="name-since-draft-ietf-quic-recovery-16">
<a href="#section-c.16" class="section-number selfRef">C.16. </a><a href="#name-since-draft-ietf-quic-recovery-16" class="section-name selfRef">Since draft-ietf-quic-recovery-16</a>
        </h2>
<ul class="normal">
<li class="normal" id="section-c.16-1.1">Unify TLP and RTO into a single PTO; eliminate min RTO, min TLP and min crypto
timeouts; eliminate timeout validation (#2114, #2166, #2168, #1017)<a href="#section-c.16-1.1" class="pilcrow">¶</a>
</li>
          <li class="normal" id="section-c.16-1.2">Redefine how congestion avoidance in terms of when the period starts (#1928,
#1930)<a href="#section-c.16-1.2" class="pilcrow">¶</a>
</li>
          <li class="normal" id="section-c.16-1.3">Document what needs to be tracked for packets that are in flight (#765, #1724,
#1939)<a href="#section-c.16-1.3" class="pilcrow">¶</a>
</li>
          <li class="normal" id="section-c.16-1.4">Integrate both time and packet thresholds into loss detection (#1969, #1212,
#934, #1974)<a href="#section-c.16-1.4" class="pilcrow">¶</a>
</li>
          <li class="normal" id="section-c.16-1.5">Reduce congestion window after idle, unless pacing is used (#2007, #2023)<a href="#section-c.16-1.5" class="pilcrow">¶</a>
</li>
          <li class="normal" id="section-c.16-1.6">Disable RTT calculation for packets that don't elicit acknowledgment (#2060,
#2078)<a href="#section-c.16-1.6" class="pilcrow">¶</a>
</li>
          <li class="normal" id="section-c.16-1.7">Limit ack_delay by max_ack_delay (#2060, #2099)<a href="#section-c.16-1.7" class="pilcrow">¶</a>
</li>
          <li class="normal" id="section-c.16-1.8">Initial keys are discarded once Handshake keys are available (#1951, #2045)<a href="#section-c.16-1.8" class="pilcrow">¶</a>
</li>
          <li class="normal" id="section-c.16-1.9">Reorder ECN and loss detection in pseudocode (#2142)<a href="#section-c.16-1.9" class="pilcrow">¶</a>
</li>
          <li class="normal" id="section-c.16-1.10">Only cancel loss detection timer if ack-eliciting packets are in flight
(#2093, #2117)<a href="#section-c.16-1.10" class="pilcrow">¶</a>
</li>
        </ul>
</section>
</div>
<div id="since-draft-ietf-quic-recovery-14">
<section id="section-c.17">
        <h2 id="name-since-draft-ietf-quic-recovery-14">
<a href="#section-c.17" class="section-number selfRef">C.17. </a><a href="#name-since-draft-ietf-quic-recovery-14" class="section-name selfRef">Since draft-ietf-quic-recovery-14</a>
        </h2>
<ul class="normal">
<li class="normal" id="section-c.17-1.1">Used max_ack_delay from transport params (#1796, #1782)<a href="#section-c.17-1.1" class="pilcrow">¶</a>
</li>
          <li class="normal" id="section-c.17-1.2">Merge ACK and ACK_ECN (#1783)<a href="#section-c.17-1.2" class="pilcrow">¶</a>
</li>
        </ul>
</section>
</div>
<div id="since-draft-ietf-quic-recovery-13">
<section id="section-c.18">
        <h2 id="name-since-draft-ietf-quic-recovery-13">
<a href="#section-c.18" class="section-number selfRef">C.18. </a><a href="#name-since-draft-ietf-quic-recovery-13" class="section-name selfRef">Since draft-ietf-quic-recovery-13</a>
        </h2>
<ul class="normal">
<li class="normal" id="section-c.18-1.1">Corrected the lack of ssthresh reduction in CongestionEvent pseudocode (#1598)<a href="#section-c.18-1.1" class="pilcrow">¶</a>
</li>
          <li class="normal" id="section-c.18-1.2">Considerations for ECN spoofing (#1426, #1626)<a href="#section-c.18-1.2" class="pilcrow">¶</a>
</li>
          <li class="normal" id="section-c.18-1.3">Clarifications for PADDING and congestion control (#837, #838, #1517, #1531,
#1540)<a href="#section-c.18-1.3" class="pilcrow">¶</a>
</li>
          <li class="normal" id="section-c.18-1.4">Reduce early retransmission timer to RTT/8 (#945, #1581)<a href="#section-c.18-1.4" class="pilcrow">¶</a>
</li>
          <li class="normal" id="section-c.18-1.5">Packets are declared lost after an RTO is verified (#935, #1582)<a href="#section-c.18-1.5" class="pilcrow">¶</a>
</li>
        </ul>
</section>
</div>
<div id="since-draft-ietf-quic-recovery-12">
<section id="section-c.19">
        <h2 id="name-since-draft-ietf-quic-recovery-12">
<a href="#section-c.19" class="section-number selfRef">C.19. </a><a href="#name-since-draft-ietf-quic-recovery-12" class="section-name selfRef">Since draft-ietf-quic-recovery-12</a>
        </h2>
<ul class="normal">
<li class="normal" id="section-c.19-1.1">Changes to manage separate packet number spaces and encryption levels (#1190,
#1242, #1413, #1450)<a href="#section-c.19-1.1" class="pilcrow">¶</a>
</li>
          <li class="normal" id="section-c.19-1.2">Added ECN feedback mechanisms and handling; new ACK_ECN frame (#804, #805,
#1372)<a href="#section-c.19-1.2" class="pilcrow">¶</a>
</li>
        </ul>
</section>
</div>
<div id="since-draft-ietf-quic-recovery-11">
<section id="section-c.20">
        <h2 id="name-since-draft-ietf-quic-recovery-11">
<a href="#section-c.20" class="section-number selfRef">C.20. </a><a href="#name-since-draft-ietf-quic-recovery-11" class="section-name selfRef">Since draft-ietf-quic-recovery-11</a>
        </h2>
<p id="section-c.20-1">No significant changes.<a href="#section-c.20-1" class="pilcrow">¶</a></p>
</section>
</div>
<div id="since-draft-ietf-quic-recovery-10">
<section id="section-c.21">
        <h2 id="name-since-draft-ietf-quic-recovery-10">
<a href="#section-c.21" class="section-number selfRef">C.21. </a><a href="#name-since-draft-ietf-quic-recovery-10" class="section-name selfRef">Since draft-ietf-quic-recovery-10</a>
        </h2>
<ul class="normal">
<li class="normal" id="section-c.21-1.1">Improved text on ack generation (#1139, #1159)<a href="#section-c.21-1.1" class="pilcrow">¶</a>
</li>
          <li class="normal" id="section-c.21-1.2">Make references to TCP recovery mechanisms informational (#1195)<a href="#section-c.21-1.2" class="pilcrow">¶</a>
</li>
          <li class="normal" id="section-c.21-1.3">Define time_of_last_sent_handshake_packet (#1171)<a href="#section-c.21-1.3" class="pilcrow">¶</a>
</li>
          <li class="normal" id="section-c.21-1.4">Added signal from TLS the data it includes needs to be sent in a Retry packet
(#1061, #1199)<a href="#section-c.21-1.4" class="pilcrow">¶</a>
</li>
          <li class="normal" id="section-c.21-1.5">Minimum RTT (min_rtt) is initialized with an infinite value (#1169)<a href="#section-c.21-1.5" class="pilcrow">¶</a>
</li>
        </ul>
</section>
</div>
<div id="since-draft-ietf-quic-recovery-09">
<section id="section-c.22">
        <h2 id="name-since-draft-ietf-quic-recovery-0">
<a href="#section-c.22" class="section-number selfRef">C.22. </a><a href="#name-since-draft-ietf-quic-recovery-0" class="section-name selfRef">Since draft-ietf-quic-recovery-09</a>
        </h2>
<p id="section-c.22-1">No significant changes.<a href="#section-c.22-1" class="pilcrow">¶</a></p>
</section>
</div>
<div id="since-draft-ietf-quic-recovery-08">
<section id="section-c.23">
        <h2 id="name-since-draft-ietf-quic-recovery-08">
<a href="#section-c.23" class="section-number selfRef">C.23. </a><a href="#name-since-draft-ietf-quic-recovery-08" class="section-name selfRef">Since draft-ietf-quic-recovery-08</a>
        </h2>
<ul class="normal">
<li class="normal" id="section-c.23-1.1">Clarified pacing and RTO (#967, #977)<a href="#section-c.23-1.1" class="pilcrow">¶</a>
</li>
        </ul>
</section>
</div>
<div id="since-draft-ietf-quic-recovery-07">
<section id="section-c.24">
        <h2 id="name-since-draft-ietf-quic-recovery-07">
<a href="#section-c.24" class="section-number selfRef">C.24. </a><a href="#name-since-draft-ietf-quic-recovery-07" class="section-name selfRef">Since draft-ietf-quic-recovery-07</a>
        </h2>
<ul class="normal">
<li class="normal" id="section-c.24-1.1">Include ACK delay in RTO(and TLP) computations (#981)<a href="#section-c.24-1.1" class="pilcrow">¶</a>
</li>
          <li class="normal" id="section-c.24-1.2">ACK delay in SRTT computation (#961)<a href="#section-c.24-1.2" class="pilcrow">¶</a>
</li>
          <li class="normal" id="section-c.24-1.3">Default RTT and Slow Start (#590)<a href="#section-c.24-1.3" class="pilcrow">¶</a>
</li>
          <li class="normal" id="section-c.24-1.4">Many editorial fixes.<a href="#section-c.24-1.4" class="pilcrow">¶</a>
</li>
        </ul>
</section>
</div>
<div id="since-draft-ietf-quic-recovery-06">
<section id="section-c.25">
        <h2 id="name-since-draft-ietf-quic-recovery-06">
<a href="#section-c.25" class="section-number selfRef">C.25. </a><a href="#name-since-draft-ietf-quic-recovery-06" class="section-name selfRef">Since draft-ietf-quic-recovery-06</a>
        </h2>
<p id="section-c.25-1">No significant changes.<a href="#section-c.25-1" class="pilcrow">¶</a></p>
</section>
</div>
<div id="since-draft-ietf-quic-recovery-05">
<section id="section-c.26">
        <h2 id="name-since-draft-ietf-quic-recovery-05">
<a href="#section-c.26" class="section-number selfRef">C.26. </a><a href="#name-since-draft-ietf-quic-recovery-05" class="section-name selfRef">Since draft-ietf-quic-recovery-05</a>
        </h2>
<ul class="normal">
<li class="normal" id="section-c.26-1.1">Add more congestion control text (#776)<a href="#section-c.26-1.1" class="pilcrow">¶</a>
</li>
        </ul>
</section>
</div>
<div id="since-draft-ietf-quic-recovery-04">
<section id="section-c.27">
        <h2 id="name-since-draft-ietf-quic-recovery-04">
<a href="#section-c.27" class="section-number selfRef">C.27. </a><a href="#name-since-draft-ietf-quic-recovery-04" class="section-name selfRef">Since draft-ietf-quic-recovery-04</a>
        </h2>
<p id="section-c.27-1">No significant changes.<a href="#section-c.27-1" class="pilcrow">¶</a></p>
</section>
</div>
<div id="since-draft-ietf-quic-recovery-03">
<section id="section-c.28">
        <h2 id="name-since-draft-ietf-quic-recovery-03">
<a href="#section-c.28" class="section-number selfRef">C.28. </a><a href="#name-since-draft-ietf-quic-recovery-03" class="section-name selfRef">Since draft-ietf-quic-recovery-03</a>
        </h2>
<p id="section-c.28-1">No significant changes.<a href="#section-c.28-1" class="pilcrow">¶</a></p>
</section>
</div>
<div id="since-draft-ietf-quic-recovery-02">
<section id="section-c.29">
        <h2 id="name-since-draft-ietf-quic-recovery-02">
<a href="#section-c.29" class="section-number selfRef">C.29. </a><a href="#name-since-draft-ietf-quic-recovery-02" class="section-name selfRef">Since draft-ietf-quic-recovery-02</a>
        </h2>
<ul class="normal">
<li class="normal" id="section-c.29-1.1">Integrate F-RTO (#544, #409)<a href="#section-c.29-1.1" class="pilcrow">¶</a>
</li>
          <li class="normal" id="section-c.29-1.2">Add congestion control (#545, #395)<a href="#section-c.29-1.2" class="pilcrow">¶</a>
</li>
          <li class="normal" id="section-c.29-1.3">Require connection abort if a skipped packet was acknowledged (#415)<a href="#section-c.29-1.3" class="pilcrow">¶</a>
</li>
          <li class="normal" id="section-c.29-1.4">Simplify RTO calculations (#142, #417)<a href="#section-c.29-1.4" class="pilcrow">¶</a>
</li>
        </ul>
</section>
</div>
<div id="since-draft-ietf-quic-recovery-01">
<section id="section-c.30">
        <h2 id="name-since-draft-ietf-quic-recovery-01">
<a href="#section-c.30" class="section-number selfRef">C.30. </a><a href="#name-since-draft-ietf-quic-recovery-01" class="section-name selfRef">Since draft-ietf-quic-recovery-01</a>
        </h2>
<ul class="normal">
<li class="normal" id="section-c.30-1.1">Overview added to loss detection<a href="#section-c.30-1.1" class="pilcrow">¶</a>
</li>
          <li class="normal" id="section-c.30-1.2">Changes initial default RTT to 100ms<a href="#section-c.30-1.2" class="pilcrow">¶</a>
</li>
          <li class="normal" id="section-c.30-1.3">Added time-based loss detection and fixes early retransmit<a href="#section-c.30-1.3" class="pilcrow">¶</a>
</li>
          <li class="normal" id="section-c.30-1.4">Clarified loss recovery for handshake packets<a href="#section-c.30-1.4" class="pilcrow">¶</a>
</li>
          <li class="normal" id="section-c.30-1.5">Fixed references and made TCP references informative<a href="#section-c.30-1.5" class="pilcrow">¶</a>
</li>
        </ul>
</section>
</div>
<div id="since-draft-ietf-quic-recovery-00">
<section id="section-c.31">
        <h2 id="name-since-draft-ietf-quic-recovery-00">
<a href="#section-c.31" class="section-number selfRef">C.31. </a><a href="#name-since-draft-ietf-quic-recovery-00" class="section-name selfRef">Since draft-ietf-quic-recovery-00</a>
        </h2>
<ul class="normal">
<li class="normal" id="section-c.31-1.1">Improved description of constants and ACK behavior<a href="#section-c.31-1.1" class="pilcrow">¶</a>
</li>
        </ul>
</section>
</div>
<div id="since-draft-iyengar-quic-loss-recovery-01">
<section id="section-c.32">
        <h2 id="name-since-draft-iyengar-quic-lo">
<a href="#section-c.32" class="section-number selfRef">C.32. </a><a href="#name-since-draft-iyengar-quic-lo" class="section-name selfRef">Since draft-iyengar-quic-loss-recovery-01</a>
        </h2>
<ul class="normal">
<li class="normal" id="section-c.32-1.1">Adopted as base for draft-ietf-quic-recovery<a href="#section-c.32-1.1" class="pilcrow">¶</a>
</li>
          <li class="normal" id="section-c.32-1.2">Updated authors/editors list<a href="#section-c.32-1.2" class="pilcrow">¶</a>
</li>
          <li class="normal" id="section-c.32-1.3">Added table of contents<a href="#section-c.32-1.3" class="pilcrow">¶</a>
</li>
        </ul>
</section>
</div>
</section>
</div>
<div id="contributors">
<section id="section-appendix.d">
      <h2 id="name-contributors">
<a href="#section-appendix.d" class="section-number selfRef">Appendix D. </a><a href="#name-contributors" class="section-name selfRef">Contributors</a>
      </h2>
<p id="section-appendix.d-1">The IETF QUIC Working Group received an enormous amount of support from many
people. The following people provided substantive contributions to this
document:<a href="#section-appendix.d-1" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="section-appendix.d-2.1">Alessandro Ghedini<a href="#section-appendix.d-2.1" class="pilcrow">¶</a>
</li>
        <li class="normal" id="section-appendix.d-2.2">Benjamin Saunders<a href="#section-appendix.d-2.2" class="pilcrow">¶</a>
</li>
        <li class="normal" id="section-appendix.d-2.3">Gorry Fairhurst<a href="#section-appendix.d-2.3" class="pilcrow">¶</a>
</li>
        <li class="normal" id="section-appendix.d-2.4">
          <p id="section-appendix.d-2.4.1">        <span class="contact-name"><span class="non-ascii">山本和彦</span> (<span class="ascii">Kazu Yamamoto</span>)</span><a href="#section-appendix.d-2.4.1" class="pilcrow">¶</a></p>
</li>
        <li class="normal" id="section-appendix.d-2.5">
          <p id="section-appendix.d-2.5.1">        <span class="contact-name"><span class="non-ascii">奥 一穂</span> (<span class="ascii">Kazuho Oku</span>)</span><a href="#section-appendix.d-2.5.1" class="pilcrow">¶</a></p>
</li>
        <li class="normal" id="section-appendix.d-2.6">Lars Eggert<a href="#section-appendix.d-2.6" class="pilcrow">¶</a>
</li>
        <li class="normal" id="section-appendix.d-2.7">Magnus Westerlund<a href="#section-appendix.d-2.7" class="pilcrow">¶</a>
</li>
        <li class="normal" id="section-appendix.d-2.8">Marten Seemann<a href="#section-appendix.d-2.8" class="pilcrow">¶</a>
</li>
        <li class="normal" id="section-appendix.d-2.9">Martin Duke<a href="#section-appendix.d-2.9" class="pilcrow">¶</a>
</li>
        <li class="normal" id="section-appendix.d-2.10">Martin Thomson<a href="#section-appendix.d-2.10" class="pilcrow">¶</a>
</li>
        <li class="normal" id="section-appendix.d-2.11">
          <p id="section-appendix.d-2.11.1">        <span class="contact-name">Mirja Kühlewind</span><a href="#section-appendix.d-2.11.1" class="pilcrow">¶</a></p>
</li>
        <li class="normal" id="section-appendix.d-2.12">Nick Banks<a href="#section-appendix.d-2.12" class="pilcrow">¶</a>
</li>
        <li class="normal" id="section-appendix.d-2.13">Praveen Balasubramanian<a href="#section-appendix.d-2.13" class="pilcrow">¶</a>
</li>
      </ul>
</section>
</div>
<div id="acknowledgments">
<section id="section-appendix.e">
      <h2 id="name-acknowledgments">
<a href="#name-acknowledgments" class="section-name selfRef">Acknowledgments</a>
    </h2>
</section>
</div>
<div id="authors-addresses">
<section id="section-appendix.f">
      <h2 id="name-authors-addresses">
<a href="#name-authors-addresses" class="section-name selfRef">Authors' Addresses</a>
      </h2>
<address class="vcard">
        <div dir="auto" class="left"><span class="fn nameRole">Jana Iyengar (<span class="role">editor</span>)</span></div>
<div dir="auto" class="left"><span class="org">Fastly</span></div>
<div class="email">
<span>Email:</span>
<a href="mailto:jri.ietf@gmail.com" class="email">jri.ietf@gmail.com</a>
</div>
</address>
<address class="vcard">
        <div dir="auto" class="left"><span class="fn nameRole">Ian Swett (<span class="role">editor</span>)</span></div>
<div dir="auto" class="left"><span class="org">Google</span></div>
<div class="email">
<span>Email:</span>
<a href="mailto:ianswett@google.com" class="email">ianswett@google.com</a>
</div>
</address>
</section>
</div>
<script>const toc = document.getElementById("toc");
toc.querySelector("h2").addEventListener("click", e => {
  toc.classList.toggle("active");
});
toc.querySelector("nav").addEventListener("click", e => {
  toc.classList.remove("active");
});
</script>
</body>
</html>
